!function(t){"function"==typeof define&&define.amd?define(t):t()}((function(){"use strict";const t=1e3/60,e=3e4,s=3e4,i=100,h=200,n=2*parseInt(t),o=5e3,a=["id","username","xp","level"],r={life:0,0:"life",sword:1,1:"sword",helm:2,2:"helm",armor:3,3:"armor",blood:4,4:"blood"},d=.25,c=500,l=2e4,m=["mouseAngleDegrees","username","isBoosting"],u=t=>t*Math.PI/180,p=(t,e,s,i,h)=>{let n=(o=t,Math.cos(u(o)));var o;let a=(t=>Math.sin(u(t)))(t);return[n*(i-e)-a*(h-s)+e,a*(i-e)+n*(h-s)+s]},g=(t,e)=>{const s=180*Math.atan2(t,e)/Math.PI;return y(s+360)},y=t=>parseInt(t%360),w=(t,e,s=!0)=>{t=s?Math.ceil(t):t,e=s?Math.floor(e):e;let i=Math.random()*(e-t);return(s?Math.floor(i):i)+t};let f=0;const{min:x,max:v,sqrt:b}=Math;class Component{constructor(){this.id=f++,this.active=!0,this.components=[]}addComponent(t){!t instanceof Component||this.components.push(t)}removeComponent(t,e=!1){this.components=this.components.filter(e=>e.id!=t.hasOwnProperty("id")?t.id:t),e&&this.components.map(s=>{s.removeComponent(t,e)})}getComponents(t=!1){return t?this.components.map(e=>e.getComponents(t).flat()):this.components}pruneComponents(t=!1){this.components=this.components.filter(t=>t.active),t&&this.components.forEach(e=>e.pruneComponents(t))}update(t,e,s){this.component.forEach(i=>i.update(t,e,s))}getPojo(){return{id:this.id,active:this.active}}}class Entity extends Component{constructor(){super()}update(t,e,s){}hasColliders(){return this.getColliders().length>0}getColliders(){return[]}onCollision(t,e,s){}}class Player extends Entity{constructor(t={}){super(),this.socket=t,this.socketId=t.id,this.username="",this.x=w(0,s),this.y=w(0,e),this.height=30,this.width=50,this.xp=0,this.level=1,this.health=10,this.items={},this.boostValue=3e3,this.isBoosting=!1,this.bot=!1,this.path=[],this.target=!1,this.skin=0,this.powerups={},this.mouseAngleDegrees=0,this.speed=500,this.frozen=!1,this.reverse=!1,this.lastLifeSpawn=250,this.locMem=[]}addLocMem(t){this.locMem.push(t),this.locMem.length>n&&this.locMem.shift()}update(t,i,h){if(this.bot&&!this.frozen&&([!1,void 0,null].includes(this.target)?this.target=new Point(this.x+w(-500,c,!1),this.y+w(-500,c,!1)):this.target instanceof Point?(this.pt=this.target,this.playerBB=new Rectangle(this.x,this.y,this.height,this.height),this.targetBB=new Rectangle(this.pt.x,this.pt.y,this.height*d,this.height*d),this.playerBB.intersects(this.targetBB)&&(this.target=new Point(this.x+w(-500,c,!1),this.y+w(-500,c,!1))),this.mouseAngleDegrees=(g(this.y-this.pt.y,this.x-this.pt.x)+180)%360):"number"==typeof this.target&&this.path.length>this.target&&(this.pt=this.path[this.target],this.playerBB=new Rectangle(this.x,this.y,this.height,this.height),this.targetBB=new Rectangle(this.pt.x,this.pt.y,this.height*d,this.height*d),this.playerBB.intersects(this.targetBB)&&(this.target=(this.target+1)%this.path.length),this.mouseAngleDegrees=(g(this.y-this.pt.y,this.x-this.pt.x)+180)%360)),!this.frozen){this.lastLifeSpawn-=t,this.addLocMem({x:this.x,y:this.y}),this.isBoosting?this.boostValue<=0?this.isBoosting=!1:this.boostValue-=t:this.boostValue<3e3&&(this.boostValue+=4),this.dir=0!=this.reverse?-2:1;const h=this.isBoosting?1.5*this.speed:this.speed;this.intendedXOffset=Math.cos(this.mouseAngleDegrees*Math.PI/180)*(t/1e3)*h*this.dir||0,this.intendedYOffset=Math.sin(this.mouseAngleDegrees*Math.PI/180)*(t/1e3)*h*this.dir||0,0!=this.reverse&&(this.hyp=b(this.intendedXOffset**2+this.intendedYOffset**2),this.reverse-=this.hyp,this.reverse<0&&(this.reverse=!1)),this.intendedXDestination=this.x+this.intendedXOffset,this.intendedYDestination=this.y+this.intendedYOffset,this.intendedXDestination>s?this.x=this.intendedXDestination-s:this.intendedXDestination<0?this.x=s+this.intendedXDestination:this.x+=this.intendedXOffset,this.intendedYDestination>e?this.y=this.intendedYDestination-e:this.intendedYDestination<0?this.y=e+this.intendedYDestination:this.y+=this.intendedYOffset,this.isBoosting&&this.lastLifeSpawn<=0&&this.locMem.length==n&&(this.lastLifeSpawn=250,i.addComponent(new Life(this.locMem[0].x,this.locMem[0].y)))}this.components.forEach(e=>e.update(t,i,h))}getWeaponColliderCoords(){let t=[];for(let e=1;e<=5;e++)t.push(new Rectangle(this.x+0+20+40*(e-1),this.y+37.5-2.5,20,2.5,this,"weapon").rotateAround(this.mouseAngleDegrees,new Point(this.x,this.y)));return t}getColliders(){return[new Rectangle(this.x,this.y,this.height,this.height,this,"damage")].concat(this.getWeaponColliderCoords())}onCollision(t,e,s){if("damage"==t.action&&e.action==r.life){let s=this.health+e.data.value,h=s>i?i:s,n=s>i?s%i:0,o=this.xp+n,a=1+parseInt(o/1e3);return t.data.health=h,t.data.xp=o,t.data.level=a,e.data.active=!1,!0}if("damage"==t.action&&"weapon"==e.action){const i=e.data.items&&1===e.data.items.sword,n=1===this.items.helm,o=1===this.items.armor;let a=2;i&&(a=3),n&&(a-=.5),o&&(a-=1);let r=v(this.health-a,0);if(t.data.health=r,1===w(0,10)&&s.addComponent(new Blood(this.x,this.y)),!r){e.data.xp+=1e3,t.data.active=!1;for(let t=0;t<5;t++){const t=w(this.x-25,this.x-h),e=w(this.x+25,this.x+h),i=1===w(0,2)?t:e,n=w(this.y-25,this.y-h),o=w(this.y+25,this.y+h),a=1===w(0,2)?n:o;s.addComponent(new Blood(i,a))}const i=[...Object.keys(this.items).filter(t=>1===this.items[t]),...Array(8).fill("health")];i.forEach((t,e)=>{const h=this.x+150,n=this.y,[o,a]=p(360/i.length*e,this.x,this.y,h,n);switch(t){case"health":s.addComponent(new Life(o,a));break;case"armor":s.addComponent(new Armor(o,a));break;case"helm":s.addComponent(new Helm(o,a));break;case"sword":s.addComponent(new Sword(o,a))}})}return!0}return"weapon"==t.action&&"weapon"==e.action?(t.data.reverse=100,t.data.mouseAngleDegrees=y(t.data.mouseAngleDegrees+w(-20,20,!0)),e.data.reverse=100,e.data.mouseAngleDegrees=y(e.data.mouseAngleDegrees+w(-20,20,!0)),!0):"damage"!=t.action||e.action!=r.sword||t.data.items.sword?"damage"!=t.action||e.action!=r.helm||t.data.items.helm?"damage"!=t.action||e.action!=r.armor||t.data.items.armor?void 0:(t.data.items=Object.assign(t.data.items,{armor:1}),e.data.active=!1,!0):(t.data.items=Object.assign(t.data.items,{helm:1}),e.data.active=!1,!0):(t.data.items=Object.assign(t.data.items,{sword:1}),e.data.active=!1,!0)}getPojo(){return Object.assign(super.getPojo(),{username:this.username,x:this.x,y:this.y,width:this.width,height:this.height,xp:this.xp,level:this.level,health:this.health,items:this.items,bot:this.bot,path:this.path,skin:this.skin,powerups:this.powerups,mouseAngleDegrees:this.mouseAngleDegrees,speed:this.speed,frozen:this.frozen,reverse:this.reverse,isBoosting:this.isBoosting,boostValue:this.boostValue},{})}}class Item extends Entity{constructor(t,e,s,i,h="",n){super(),this.x=t,this.y=e,this.width=s,this.height=i,this.type="string"==typeof h?r[h]:h,this.value=n,this._rend={width:s,height:i,value:n}}getColliders(){return[new Rectangle(this.x,this.y,this.width,this.height,this,this.type)]}defaultDiffs(){return Object.assign(this._rend.width!=this.width&&{width:this.width},this._rend.height!=this.height&&{height:this.height},this._rend.value!=this.value&&{value:this.value})}getPojo(){return Object.assign(super.getPojo(),{x:this.x,y:this.y,type:this.type},this.defaultDiffs(),{})}}class Blood extends Item{constructor(t,e){super(t,e,20,20,"blood")}}class Life extends Item{constructor(t,e,s=10){super(t,e,10,10,"life",s)}}class Sword extends Item{constructor(t,e){super(t,e,20,20,"sword")}}class Helm extends Item{constructor(t,e){super(t,e,20,20,"helm")}}class Armor extends Item{constructor(t,e){super(t,e,20,20,"armor")}}class Point{constructor(t,e){this.x=t,this.y=e}rotateAround(t,e=new Point(0,0)){let[s,i]=p(t,e.x,e.y,this.x,this.y);return this.x=s,this.y=i,this}}class Rectangle{constructor(t,e,s,i,h,n){this.x=t||0,this.y=e||0,this.w=s||0,this.h=i||0,this.data=h,this.action=n}contains(t){return t.x>=this.x-this.w&&t.x<=this.x+this.w&&t.y>=this.y-this.h&&t.y<=this.y+this.h}intersects(t){return this.x-this.w<t.x+t.w&&this.x+this.w>t.x-t.w&&this.y-this.h<t.y+t.h&&this.y+this.h>t.y-t.h}pure(){let{x:t,y:e,w:s,h:i,action:h}=this;return{x:t,y:e,w:s,h:i,action:h}}rotateAround(t,e=new Point(0,0)){let s=new Point(this.x-this.w,this.y-this.h).rotateAround(t,e),i=new Point(this.x-this.w,this.y+this.h).rotateAround(t,e),h=new Point(this.x+this.w,this.y-this.h).rotateAround(t,e),n=new Point(this.x+this.w,this.y+this.h).rotateAround(t,e);return this.toAABB([s,i,h,n])}toAABB(t=[]){let e=t.map(t=>t.x),s=t.map(t=>t.y),i=x(...e),h=x(...s),n=(v(...e)-i)/2,o=(v(...s)-h)/2;return this.x=i+n,this.y=h+o,this.w=n,this.h=o,this}}class Quadtree{constructor(t=new Rectangle(15e3,15e3,15e3,15e3),e=5){this.boundry=t,this.capacity=e,this.points=[],this.divided=!1}subdivide(){this.divided=!0;let t=this.boundry.x,e=this.boundry.y,s=this.boundry.w,i=this.boundry.h;this.northWest=new Quadtree(new Rectangle(t-s/2,e-i/2,s/2,i/2),this.capacity),this.northEast=new Quadtree(new Rectangle(t+s/2,e-i/2,s/2,i/2),this.capacity),this.southWest=new Quadtree(new Rectangle(t-s/2,e+i/2,s/2,i/2),this.capacity),this.southEast=new Quadtree(new Rectangle(t+s/2,e+i/2,s/2,i/2),this.capacity)}insert(t){return!!this.boundry.contains(t)&&(this.points.length<this.capacity?(this.points.push(t),!0):(this.divided||this.subdivide(),this.northWest.insert(t)||this.northEast.insert(t)||this.southWest.insert(t)||this.southEast.insert(t)))}query(t){let e=[];return this.boundry.intersects(t)&&(e=this.points.slice(),this.divided&&e.push(...this.northWest.query(t),...this.northEast.query(t),...this.southWest.query(t),...this.southEast.query(t))),e}}class Spawner extends Component{constructor(t,e,s,i){super(),this.max=t,this.lastTime=0,this.respawn=e,this.checkFn=s,this.entityFn=i}update(t,e,s=[],i={}){if(this.lastTime-=t,this.lastTime<0){this.lastTime=this.respawn;let t=this.checkFn(s,i);if(t<this.max)for(let s=0;s<this.max-t;s++)this.temp=this.entityFn(),e.addComponent(this.temp)}}}const C=new class Game extends Component{constructor(){super();this.world=new Rectangle(15e3,15e3,15e3,15e3),this.leaderTick=o,this.mapTick=o}checkCollisions(t){let e={};this.components.forEach(s=>{s.active&&s instanceof Entity&&s.hasColliders()&&s.getColliders().forEach(i=>{i.data&&i.action&&this.quadTree.query(i).forEach(h=>{s.id!=h.data.id&&h.data.active&&(e[i.data.id]&&e[i.data.id][h.data.id]||i.intersects(h)&&s.onCollision(i,h,t)&&(e[i.data.id]=e[i.data.id]||{},e[i.data.id][h.data.id]=!0))})})})}update(t,e,s){this.leaderTick-=t,this.mapTick-=t,this.quadTree=new Quadtree(this.world);let i=[],h={};this.getComponents().forEach(s=>{s instanceof Player&&i.push(s),s instanceof Item&&(h[s.constructor.name]=h[s.constructor.name]||0,h[s.constructor.name]++),s.active&&(s.update(t,e,i),s instanceof Entity&&s.getColliders().forEach(t=>this.quadTree.insert(t)))}),this.checkCollisions(e),i.forEach(t=>{if(t.bot)return;let e={},s={},h=new Rectangle(t.x,t.y,2e3,2e3);this.quadTree.query(h).forEach(t=>{t.data&&h.intersects(t)&&(t.data instanceof Item&&(s[t.data.id]=t.data.getPojo()),t.data instanceof Player&&(e[t.data.id]=t.data.getPojo()))}),io.to(t.socketId).emit("delta",{players:e,items:s}),this.mapTick<=0&&(io.to(t.socketId).emit("minimap",{minimap:i.filter(e=>e.socketId!=t.socketId).map(t=>({x:t.x,y:t.y,item:t.items.sword||t.items.helm||t.items.armor}))}),this.mapTick=o)}),this.leaderTick<=0&&(io.emit("leaderboard",{leaderboard:i.map(t=>a.reduce((e,s)=>Object.assign(e,{[s]:t[s]}),{})).sort((t,e)=>t.xp-e.xp).slice(-10).reverse()}),this.leaderTick=o),s.forEach(s=>{s.update(t,e,i,h)}),this.pruneComponents()}},B=new Spawner(50,l,t=>t.filter(t=>t.bot).length,()=>{let t="bot"+Date.now(),i=new Player({id:t});return i.x=w(0,s),i.y=w(0,e),i.username=t,i.bot=!0,i}),A=new Spawner(5,l,(t,e)=>t.filter(t=>t.items&&1==t.items.helm).length+e.Helm||0,()=>new Helm(w(0,s),w(0,e))),D=new Spawner(5,l,(t,e)=>t.filter(t=>t.items&&1==t.items.sword).length+e.Sword||0,()=>new Sword(w(0,s),w(0,e))),P=new Spawner(5,l,(t,e)=>t.filter(t=>t.items&&1==t.items.armor).length+e.Armor||0,()=>new Armor(w(0,s),w(0,e))),k=new Spawner(30,l,(t,e)=>e.Life||0,()=>new Life(w(0,s),w(0,e)));io.on("connection",t=>{const e=new Player(t);t.on("disconnect",()=>{e.active=!1}),t.on("data",t=>{Object.keys(t).forEach(s=>{m.includes(s)&&(e[s]=t[s])})}),t.on("play",s=>{Object.keys(s).forEach(t=>{m.includes(t)&&(e[t]=s[t])}),io.to(t.id).emit("sync",{currentPlayer:{id:e.id}})}),C.addComponent(e)});let E,M,O=0,I=0,j=Date.now();const T=()=>{E=j,j=Date.now(),O=j-E,C.update(O,C,[B,A,D,P,k]),I=Date.now()-j,M=Math.max(t-I,0),setTimeout(T,M)};setTimeout(T,t),module.exports=Object.assign({state:(t,e,s)=>{const i=C.getComponents();let h={},n={};return i.forEach(t=>{h[t.constructor.name]=h[t.constructor.name]||0,n[t.constructor.name]=n[t.constructor.name]||0,t.active?h[t.constructor.name]+=1:n[t.constructor.name]+=1}),e.send(`<pre>${JSON.stringify({components:i.length,types:h,inactive:n},null,2)}</pre>`)}})}));
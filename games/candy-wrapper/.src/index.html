<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <title>Candy Wrapper</title>
    <style>body[orient="landscape"]
{
    font-family: 'Segoe UI', sans-serif
}

.squareBtn {
        
        -moz-box-shadow:inset 0px -4px 0px -1px #135f8f;
        -webkit-box-shadow:inset 0px -4px 0px -1px #135f8f;
        box-shadow:inset 0px -4px 0px -1px #135f8f;
        
        background-color:#2980b9;
        
        -moz-border-radius:6px;
        -webkit-border-radius:6px;
        border-radius:6px;
        
        display:inline-block;
        color:#ffffff;
        font-family:Trebuchet MS;
        font-size:20px;
        font-weight:bold;
        padding:10px 10px;
        text-decoration:none;

        cursor:pointer;
        position:absolute;
        text-align:center;
        width: 40%;
        height: 10%;
        
        text-shadow:1px 2px 1px #005085;
        z-index: 10;
    }
    .squareBtn:hover {
        
        background-color:#3498db;
    }
    .squareBtn:active {
        position: absolute;
        height: 12%;
    }

.about {
    font-size: 10px;
}

.popup {
    position:absolute;
    z-index: 1000;

    -moz-box-shadow: inset 0px 1px 0px 0px #23395e;
    -webkit-box-shadow: inset 0px 1px 0px 0px #23395e;
    box-shadow: inset 0px 1px 0px 0px #23395e;
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0.05, #2e466e), color-stop(1, #415989));
    background: -moz-linear-gradient(top, #2e466e 5%, #415989 100%);
    background: -webkit-linear-gradient(top, #2e466e 5%, #415989 100%);
    background: -o-linear-gradient(top, #2e466e 5%, #415989 100%);
    background: -ms-linear-gradient(top, #2e466e 5%, #415989 100%);
    background: linear-gradient(to bottom, #2e466e 5%, #415989 100%);
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#2e466e', endColorstr='#415989',GradientType=0);
    background-color: #2e466e;
    -moz-border-radius: 7px;
    -webkit-border-radius: 7px;
    border-radius: 7px;
    border: 1px solid #1f2f47;
    display: inline-block;
    color: #ffffff;
    font-family: Trebuchet MS;
    font-size: 17px;
    font-weight: bold;
    padding: 6px 11px;
    text-decoration: none;
    text-shadow: 0px 1px 0px #263666;
}
</style>

    
    
    

    <script>var Vector2 = (function () {
    function Vector2(x, y) {
        this.X = 0;
        this.Y = 0;
        if (x)
            this.X = x;
        if (y)
            this.Y = y;
    }
    Vector2.prototype.set = function (x, y) {
        this.X = x;
        this.Y = y;
        return this;
    };

    Vector2.prototype.length = function () {
        return Math.sqrt(this.X * this.X + this.Y * this.Y);
    };

    Vector2.prototype.add = function (v) {
        this.X += v.X;
        this.Y += v.Y;
        return this;
    };

    Vector2.prototype.subScalars = function (x, y) {
        this.X -= x;
        this.Y -= y;
        return this;
    };

    Vector2.prototype.sub = function (v) {
        this.X -= v.X;
        this.Y -= v.Y;
        return this;
    };

    Vector2.prototype.mulScalar = function (a) {
        this.X *= a;
        this.Y *= a;
        return this;
    };

    Vector2.prototype.normalize = function () {
        var l = 1 / this.length();
        this.X *= l;
        this.Y *= l;
        return this;
    };

    Vector2.prototype.dot = function (v) {
        return this.X * v.X + this.Y * v.Y;
    };

    Vector2.prototype.copy = function (v) {
        this.X = v.X;
        this.Y = v.Y;
        return this;
    };

    Vector2.prototype.collides = function (rad, pos2, rad2) {
        var x = this.X - pos2.X, y = this.Y - pos2.Y;
        return Math.sqrt(x * x + y * y) < rad + rad2;
    };
    return Vector2;
})();
        //# sourceMappingURL=vector2.js.map
        ///<reference path='vector2.ts'/>
        ///<reference path='candy.ts'/>
        var PathType;
        (function (PathType) {
            PathType[PathType["Line"] = 0] = "Line";
            PathType[PathType["Radial"] = 1] = "Radial";
        })(PathType || (PathType = {}));
        ;

        var PathPart = (function () {
            function PathPart(type, start, end, radius, startAngle, endAngle) {
                this.Type = PathType.Line;
                this.Start = null;
                this.End = null;
                this.Radius = 0.0;
                this.StartAngle = 0.0;
                this.EndAngle = 0.0;
                this.Type = type;
                this.Start = start;
                this.End = end;
                this.Radius = radius;
                this.StartAngle = startAngle;
                this.EndAngle = endAngle;

                if (this.Type === PathType.Line) {
                    var x = this.End.X - this.Start.X;
                    var y = this.End.Y - this.Start.Y;
                    this.Length = Math.sqrt(x * x + y * y);
                } else {
                    this.Length = Math.abs(this.EndAngle - this.StartAngle) * this.Radius;
                }
            }
            return PathPart;
        })();

        var Path = (function () {
            function Path(parts, idx) {
                this.Idx = 0;
                this.Parts = null;
                this.NextCandyTime = 0.0;
                this.LastCandy = null;
                this.Parts = parts;
                this.Idx = idx;
            }
            Path.prototype.addEnemy = function (candy) {
                this.LastCandy = candy;
            };

            Path.prototype.render = function (context) {
                var part = this.Parts[0];

                context.beginPath();
                context.moveTo(part.Start.X, part.Start.Y);

                for (var i = 0; i < this.Parts.length; ++i) {
                    part = this.Parts[i];
                    if (part.Type === PathType.Line) {
                        context.lineTo(part.End.X, part.End.Y);
                    } else {
                        context.arc(part.Start.X, part.Start.Y, part.Radius, part.StartAngle, part.EndAngle, part.StartAngle > part.EndAngle);
                    }
                }

                context.stroke();
            };
            return Path;
        })();
        //# sourceMappingURL=path.js.map
        ///<reference path='vector2.ts'/>
        ///<reference path='sprite_manager.ts'/>
        var Sprite = (function () {
            function Sprite(img, x, y, width, height, spriteManager) {
                this.Img = null;
                this.X = 0;
                this.Y = 0;
                this.Width = 0;
                this.Height = 0;
                this.SpriteMan = null;
                this.Img = img;
                this.X = x;
                this.Y = y;
                this.Width = width;
                this.Height = height;
                this.SpriteMan = spriteManager;
            }
            Sprite.prototype.draw = function (context, pos, size, angle, offset) {
                var gscale = this.SpriteMan.GlobalScale;
                if (angle) {
                    var sin = Math.sin(angle) * gscale, cos = Math.cos(angle) * gscale;
                    context.setTransform(cos, sin, -sin, cos, pos.X * gscale, pos.Y * gscale);
                } else
                    context.setTransform(gscale, 0, 0, gscale, pos.X * gscale, pos.Y * gscale);
                if (offset)
                    context.drawImage(this.Img, this.X, this.Y, this.Width, this.Height, -size.X * 0.5 - offset.X, -size.Y * 0.5 - offset.Y, size.X, size.Y);
                else
                    context.drawImage(this.Img, this.X, this.Y, this.Width, this.Height, -size.X * 0.5, -size.Y * 0.5, size.X, size.Y);
            };

            Sprite.prototype.drawLabel = function (context, pos, scale) {
                var gscale = this.SpriteMan.GlobalScale * scale;
                context.setTransform(gscale, 0, 0, gscale, pos.X * gscale, pos.Y * gscale);
                context.drawImage(this.Img, this.X, this.Y, this.Width, this.Height, 0, 0, this.Width, this.Height);
            };
            return Sprite;
        })();
        //# sourceMappingURL=sprite.js.map
        ///<reference path='vector2.ts'/>
        ///<reference path='sprite_manager.ts'/>
        var InputManager = (function () {
            function InputManager(canvas, spriteManager) {
                //Tap gesture
                this.Tap = { pos: new Vector2(), justTapped: false };
                this.MaxHoldTime = 250.0;
                this.MaxDeltaDist = 10;
                this.TouchPos = new Vector2();
                this.TouchTime = 0.0;
                var that = this;
                canvas.addEventListener('touchstart', function (e) {
                    if (e.touches.length === 1) {
                        that.TouchPos.set(e.touches[0].pageX - canvas.clientLeft, e.touches[0].pageY - canvas.clientTop).mulScalar(1 / spriteManager.GlobalScale);
                        that.TouchTime = Date.now();
                    }
                }, false);

                canvas.addEventListener('touchend', function (e) {
                    var posX = e.changedTouches[0].pageX - canvas.clientLeft, posY = e.changedTouches[0].pageY - canvas.clientTop;

                    if (e.touches.length === 0 && Date.now() - that.TouchTime < that.MaxHoldTime && that.TouchPos.subScalars(posX, posY).length() < that.MaxDeltaDist) {
                        that.Tap.justTapped = true;
                        that.Tap.pos.set(posX, posY).mulScalar(1 / spriteManager.GlobalScale);
                    }
                }, false);

                canvas.addEventListener('click', function (e) {
                    that.Tap.justTapped = true;
                    that.Tap.pos.set(e.pageX - canvas.clientLeft, e.pageY - canvas.clientTop).mulScalar(1 / spriteManager.GlobalScale);
                }, false);
            }
            InputManager.prototype.update = function () {
                this.Tap.justTapped = false;
            };
            return InputManager;
        })();
        //# sourceMappingURL=input_manager.js.map
        ///<reference path='sprite.ts'/>
        var SpriteManager = (function () {
            function SpriteManager(globalScale, screenSize) {
                this.RawSprites = [];
                this.Atlas = null;
                this.BackgroundCanvas = null;
                this.GlobalScale = 1.0;
                this.LucksCanvas = null;
                this.Sprites = {};
                this.LucksSprites = {};
                this.GlobalScale = globalScale;

                //create canvas and get context
                var canvas = document.createElement('canvas');
                canvas.width = canvas.height = 512;
                this.Atlas = canvas;
                var context = canvas.getContext('2d');

                //    sprites = new Array(this.RawSprites.length);
                //this.Sprites = sprites;
                //for (var i = 0; i < sprites.length; ++i)
                //{
                //    context.translate((i * 64) % canvas.width, (i * 64) / canvas.width);
                //    Function('function(ctx){ctx.' + this.RawSprites[i].replace(/';'/g, ';ctx.').
                //        substring(0, this.RawSprites[i].length - 4) + '}')(context);
                //}
                //rendering spinner parts
                context.shadowBlur = 5 * globalScale;
                context.shadowColor = '#007FFF';
                context.strokeStyle = '#007FFF';
                context.lineWidth = 5;
                context.lineCap = 'round';
                context.beginPath();
                context.arc(274, 228, 220, 1.66 * Math.PI, 1.85 * Math.PI);
                context.stroke();

                //this.Sprites['arc'] = new Sprite(canvas, 260, 0, 246, 246, this);
                this.Sprites['arc'] = new Sprite(canvas, 264, 0, 246, 246, this);

                //wrappers sprites
                context.shadowBlur = 5 * globalScale;
                context.lineWidth = 1;

                context.fillStyle = context.shadowColor = '#0066CC';
                context.beginPath();
                context.arc(64, 64, 64, 0, Math.PI * 2);
                context.fill();
                this.Sprites['blueberry'] = new Sprite(canvas, 0, 0, 128, 128, this);

                context.fillStyle = context.shadowColor = '#FFCC00';
                context.beginPath();
                context.arc(128 + 64, 64, 64, 0, Math.PI * 2);
                context.fill();
                this.Sprites['lemon'] = new Sprite(canvas, 128, 0, 128, 128, this);

                context.fillStyle = context.shadowColor = '#CC0000';
                context.beginPath();
                context.arc(64, 64 + 128, 64, 0, Math.PI * 2);
                context.fill();
                this.Sprites['strawberry'] = new Sprite(canvas, 0, 128, 128, 128, this);

                context.fillStyle = context.shadowColor = '#00CC00';
                context.beginPath();
                context.arc(64 + 128, 64 + 128, 64, 0, Math.PI * 2);
                context.fill();
                this.Sprites['apple'] = new Sprite(canvas, 128, 128, 128, 128, this);

                //
                //candy sprites
                //
                //bonus sprites
                this.Sprites['SlowTime'] = new Sprite(canvas, 0, 0, 128, 128, this);
                this.Sprites['FiftyByFifty'] = new Sprite(canvas, 128, 0, 128, 128, this);
                this.Sprites['NoPenalty'] = new Sprite(canvas, 0, 128, 128, 128, this);
                this.Sprites['MinusPath'] = new Sprite(canvas, 128, 128, 128, 128, this);

                this.Sprites['readyRotor'] = new Sprite(canvas, 0, 0, 128, 128, this);

                //
                context.strokeStyle = context.shadowColor = '';
                context.lineWidth = 14;
                context.beginPath();
                context.moveTo(266, 266 + context.lineWidth);
                context.lineTo(267, 266 + context.lineWidth);
                context.stroke();
                this.Sprites['barSample'] = new Sprite(canvas, 266, 266, 1, context.lineWidth * 2, this);

                //prerender game background
                var bcanvas = document.createElement('canvas');
                bcanvas.width = screenSize.X;
                bcanvas.height = screenSize.Y;
                this.BackgroundCanvas = bcanvas;
                var bcontext = bcanvas.getContext('2d');
                var coreColor = 'rgba(0,0,0,0)';

                bcontext.fillStyle = coreColor;
                bcontext.fillRect(0, 0, bcanvas.width, bcanvas.height);

                var grd = bcontext.createRadialGradient(920 * globalScale, 360 * globalScale, 50 * globalScale, 920 * globalScale, 360 * globalScale, 500 * globalScale);
                grd.addColorStop(0, '#003399');
                grd.addColorStop(1, coreColor);

                bcontext.beginPath();
                bcontext.fillStyle = grd;
                bcontext.rect(0, 0, bcanvas.width, bcanvas.height);
                bcontext.fill();

                //prerendered GUI
                bcontext.setTransform(globalScale, 0, 0, globalScale, 0, 0);
                bcontext.fillStyle = '#007FFF';
                bcontext.font = '22px bold marker felt, comic sans ms, arial';
                bcontext.textBaseline = 'top';
                bcontext.fillText('Score:', 10, 50);
                bcontext.fillText('Speed:', 10, 80);

                bcontext.globalAlpha = 0.2;
                this.Sprites['barSample'].draw(bcontext, new Vector2(180, 670), new Vector2(120, 24));
                bcontext.globalAlpha = 1.0;

                bcontext.setTransform(1, 0, 0, 1, 0, 0);

                //draw luck sprites
                var lcanvas = document.createElement('canvas');
                lcanvas.width = lcanvas.height = 512;
                var lcontext = lcanvas.getContext('2d');

                lcontext.shadowBlur = 16;
                lcontext.lineWidth = 5;
                lcontext.font = '42px bold marker felt, comic sans ms, arial';
                lcontext.textBaseline = 'top';

                lcontext.fillStyle = lcontext.shadowColor = '#FF3333';
                lcontext.fillText('Bad Luck', 16, 16);

                lcontext.fillStyle = lcontext.shadowColor = '#6599FF';
                lcontext.fillText('Ok', 16, 90);

                lcontext.fillStyle = lcontext.shadowColor = '#9CFF00';
                lcontext.fillText('Good', 16, 164);

                lcontext.fillStyle = lcontext.shadowColor = '#990099';
                lcontext.fillText('Awesome', 16, 238);

                lcontext.fillStyle = lcontext.shadowColor = '#FF9900';
                lcontext.fillText('Mega', 16, 312);

                this.LucksSprites[LuckLevel.Bad] = new Sprite(lcanvas, 0, 0, 512, 74, this);
                this.LucksSprites[LuckLevel.Ok] = new Sprite(lcanvas, 0, 74, 512, 74, this);
                this.LucksSprites[LuckLevel.Good] = new Sprite(lcanvas, 0, 148, 512, 74, this);
                this.LucksSprites[LuckLevel.Awesome] = new Sprite(lcanvas, 0, 222, 512, 74, this);
                this.LucksSprites[LuckLevel.Mega] = new Sprite(lcanvas, 0, 296, 512, 74, this);

                document.body.appendChild(lcanvas);
            }
            return SpriteManager;
        })();
        //# sourceMappingURL=sprite_manager.js.map
        ///<reference path='sprite.ts'/>
        ///<reference path='sprite_manager.ts'/>
        ///<reference path='spinner.ts'/>
        ///<reference path='vector2.ts'/>
        var WrapperType;
        (function (WrapperType) {
            WrapperType[WrapperType["Apple"] = 0] = "Apple";
            WrapperType[WrapperType["Strawberry"] = 1] = "Strawberry";
            WrapperType[WrapperType["Blueberries"] = 2] = "Blueberries";
            WrapperType[WrapperType["Lemon"] = 3] = "Lemon";
        })(WrapperType || (WrapperType = {}));

        var Wrapper = (function () {
            function Wrapper(type, size, spriteManager) {
                this.WSprite = null;
                this.Parent = null;
                this.Type = WrapperType.Apple;
                this.Position = new Vector2();
                this.Size = new Vector2();
                this.Radius = 0.0;
                this.Type = type;
                this.Size.copy(size);
                this.Radius = size.X;
                this.WSprite = spriteManager.Sprites[type === WrapperType.Apple ? 'apple' : type === WrapperType.Strawberry ? 'strawberry' : type === WrapperType.Blueberries ? 'blueberry' : 'lemon'];
            }
            Wrapper.prototype.update = function (rotation, timeDelta) {
            };

            Wrapper.prototype.checkSpin = function (tapPos) {
                if (this.Position.collides(this.Radius, tapPos, 0.0)) {
                    //TODO? : Tapped on guard actions
                    return true;
                }
                return false;
            };

            Wrapper.prototype.render = function (context, rotation, timeDelta) {
                this.WSprite.draw(context, this.Position, this.Size, rotation);
            };
            return Wrapper;
        })();
        //# sourceMappingURL=wrapper.js.map
        ///<reference path='sprite.ts'/>
        ///<reference path='sprite_manager.ts'/>
        ///<reference path='vector2.ts'/>
        var Spinner = (function () {
            function Spinner(radius, position, rotationSpeed, children, spriteManager) {
                this.SSprite = null;
                this.Parent = null;
                this.Rotation = 0.0;
                this.TargetRotation = -1.0;
                this.Radius = 0.0;
                this.Size = new Vector2();
                this.Offset = new Vector2();
                this.RotationSpeed = 0.0;
                this.Position = new Vector2();
                this.Radius = radius;
                this.Offset.set(-radius, radius).mulScalar(0.5);
                this.RotationSpeed = rotationSpeed;
                this.Position.copy(position);
                this.Size.set(radius, radius);
                this.Children = children;
                this.SSprite = spriteManager.Sprites['arc'];

                for (var i = 0; i < children.length; ++i)
                    children[i].Parent = this;
            }
            Spinner.prototype.update = function (rotation, timeDelta) {
                if (this.TargetRotation !== -1.0) {
                    this.Rotation += this.RotationSpeed * timeDelta;
                    if (this.Rotation >= this.TargetRotation) {
                        this.Rotation = this.TargetRotation;
                        this.TargetRotation = -1.0;
                    }
                }

                var totalRotation = rotation + this.Rotation, childRotation = 0.0, rad = this.Radius, child;

                for (var i = this.Children.length - 1; i >= 0; --i) {
                    childRotation = totalRotation + Math.PI * 0.5 * i;
                    child = this.Children[i];
                    child.Position.set(Math.cos(childRotation) * rad, Math.sin(childRotation) * rad).add(this.Position);
                    child.update(rotation, timeDelta);
                }
            };

            Spinner.prototype.checkSpin = function (tapPos) {
                if (this.TargetRotation !== -1.0)
                    return true;

                for (var i = this.Children.length - 1; i >= 0; --i) {
                    if (this.Children[i].checkSpin(tapPos))
                        return true;
                }

                var dx = tapPos.X - this.Position.X, dy = tapPos.Y - this.Position.Y;

                if (Math.sqrt(dx * dx + dy * dy) <= this.Radius) {
                    this.TargetRotation = this.Rotation + Math.PI * 0.5;

                    //for (var i = this.Children.length - 1; i >= 0; --i)
                    //    this.Children[i].TargetRotation = this.Children[i].Rotation + Math.PI * 0.5;
                    return true;
                }

                return false;
            };

            Spinner.prototype.render = function (context, rotation, timeDelta) {
                var totalRotation = rotation + this.Rotation, i = 0;

                for (i = 0; i < 4; ++i) {
                    this.SSprite.draw(context, this.Position, this.Size, this.Rotation + i * 0.5 * Math.PI, this.Offset);
                }

                for (i = this.Children.length - 1; i >= 0; --i) {
                    this.Children[i].render(context, totalRotation + Math.PI * 0.5 * i, timeDelta);
                }
            };
            return Spinner;
        })();
        //# sourceMappingURL=spinner.js.map
        ///<reference path='vector2.ts'/>
        ///<reference path='sprite.ts'/>
        ///<reference path='sprite_manager.ts'/>
        ///<reference path='path.ts'/>
        ///<reference path='wrapper.ts'/>
        var Candy = (function () {
            function Candy(size) {
                this.CSprite = null;
                this.Wrapped = true;
                this.Type = WrapperType.Apple;
                this.Position = new Vector2();
                this.Size = new Vector2();
                this.Radius = 0.0;
                this.Speed = 0.0;
                this.CPath = null;
                this.PathPartIdx = 0;
                this.PartInterpolation = 0.0;
                this.PartSpeed = 0.0;
                this.FinishedPath = true;
                this.Size.copy(size);
                this.Radius = size.X;
            }
            Candy.prototype.revive = function (type, spriteManager, path, speed) {
                this.Type = type;
                this.CPath = path;
                this.Speed = speed;
                this.Wrapped = false;
                this.FinishedPath = false;
                this.PathPartIdx = 0;
                this.PartInterpolation = 0.0;
                this.Position.set(-100, -100);
                this.CSprite = spriteManager.Sprites[type === WrapperType.Apple ? 'apple' : type === WrapperType.Strawberry ? 'strawberry' : type === WrapperType.Blueberries ? 'blueberry' : 'lemon'];

                path.addEnemy(this);
                this.PartSpeed = this.Speed / this.CPath.Parts[0].Length;
            };

            Candy.prototype.update = function (timeDelta) {
                if (!this.FinishedPath) {
                    var parts = this.CPath.Parts, part = parts[this.PathPartIdx];
                    if (part.Type === PathType.Line) {
                        this.Position.copy(part.End).sub(part.Start).mulScalar(this.PartInterpolation).add(part.Start);
                    } else {
                        var angle = (part.StartAngle + (part.EndAngle - part.StartAngle) * this.PartInterpolation);
                        this.Position.set(part.Radius * Math.cos(angle), part.Radius * Math.sin(angle)).add(part.Start);
                    }

                    this.PartInterpolation += this.PartSpeed * timeDelta;
                    if (this.PartInterpolation >= 1.0) {
                        this.PartInterpolation -= 1.0;
                        ++this.PathPartIdx;
                        if (this.PathPartIdx < parts.length) {
                            part = parts[this.PathPartIdx];
                            this.PartInterpolation *= (parts[this.PathPartIdx - 1].Length / part.Length);
                            this.PartSpeed = this.Speed / part.Length;
                        } else {
                            this.FinishedPath = true;
                            return true;
                        }
                    }
                }

                return false;
            };

            Candy.prototype.render = function (context, timeDelta) {
                if (this.FinishedPath || this.Wrapped)
                    return;

                this.CSprite.draw(context, this.Position, this.Size);
            };
            return Candy;
        })();
        //# sourceMappingURL=candy.js.map
        ///<reference path='spinner.ts'/>
        ///<reference path='sprite_manager.ts'/>
        ///<reference path='input_manager.ts'/>
        ///<reference path='wrapper.ts'/>
        ///<reference path='candy.ts'/>
        ///<reference path='path.ts'/>
        var LuckLevel;
        (function (LuckLevel) {
            LuckLevel[LuckLevel["Bad"] = 0] = "Bad";
            LuckLevel[LuckLevel["Ok"] = 1] = "Ok";
            LuckLevel[LuckLevel["Good"] = 2] = "Good";
            LuckLevel[LuckLevel["Awesome"] = 3] = "Awesome";
            LuckLevel[LuckLevel["Mega"] = 4] = "Mega";
        })(LuckLevel || (LuckLevel = {}));
        ;

        var Level = (function () {
            function Level(game, wave, canvas, context, spriteManager, inputManager, screenSize) {
                this.Canvas = null;
                this.Context = null;
                this.Game = null;
                this.SpriteMan = null;
                this.InputMan = null;
                this.GSpinner = null;
                this.Spinners = null;
                this.ScreenSize = new Vector2();
                this.ScreenCenter = new Vector2();
                this.SpinnerSpeed = 7.0;
                this.Wave = 1;
                this.Paths = null;
                this.PathSmoothness = 40.0;
                this.PathsCanvas = null;
                this.Candies = null;
                this.CandyRadius = 17.0;
                this.MaxCandies = 60;
                this.BaseCandySpeed = 100.0;
                this.CurrentCandySpeed = this.BaseCandySpeed;
                this.WrapperRadius = 35.0;
                this.Wrappers = null;
                this.Score = 0;
                this.BaseScorePerCandy = 10;
                this.TotalWrappedAmount = 0;
                this.TotalSpinsDone = 0;
                this.CurrentLuck = LuckLevel.Good;
                this.LuckMeter = 0;
                this.TotalTimeElapsed = 0.0;
                this.TimeToIncreaseSpeed = 30.0;
                this.WaitingForNewWave = false;
                this.CandiesCollected = 0;
                this.CandiesToUp = [5, 12, 18, 26, 30];
                this.CandiesToLose = [5, 6, 5, 3, 1];
                this.CandiesLost = 0;
                this.MaxLuckMeter = this.LuckMeter;
                this.MeterPos = new Vector2(120, 575);
                this.MeterBarPos = new Vector2(120, 670);
                this.MeterSize = new Vector2(0, 24);
                this.Game = game;
                this.Wave = wave;
                this.Canvas = canvas;
                this.Context = context;
                this.SpriteMan = spriteManager;
                this.MeterSampler = spriteManager.Sprites['barSample'];
                this.InputMan = inputManager;
                this.ScreenSize.copy(screenSize);
                this.ScreenCenter.copy(screenSize).mulScalar(0.5);

                //generate level
                var wrappers = new Array(16), swrappers = null, spinners = new Array(4), wrapperSize = new Vector2(this.WrapperRadius, this.WrapperRadius), i = 0, j = 0, types = [[0, 1, 2, 3], [0, 2, 1, 3], [0, 1, 3, 2], [0, 3, 2, 1]];

                for (i = 0; i < 4; ++i) {
                    swrappers = new Array(4);
                    for (j = 0; j < 4; ++j) {
                        swrappers[j] = new Wrapper(types[i][j], wrapperSize, spriteManager);
                        wrappers[i * 4 + j] = swrappers[j];
                    }
                    spinners[i] = new Spinner(80, new Vector2(), this.SpinnerSpeed, swrappers, spriteManager);
                }

                this.Spinners = spinners;
                this.GSpinner = new Spinner(220, new Vector2(920, 360), this.SpinnerSpeed, spinners, spriteManager);
                this.Wrappers = wrappers;

                //generate paths
                var pathsCoords = [
                    [-50, 360, 1480, 360],
                    [-70, 280, 760, 280, 840, 140, 940, 40, 1040, 60, 1160, 160, 1480, 160],
                    [-88, 440, 760, 440, 840, 580, 940, 680, 1040, 660, 1160, 560, 1480, 560]
                ];
                var pathSmooth = this.PathSmoothness, paths = [], angSin = 0.0, angCos = 0.0, offset = 0.0, dir1 = new Vector2(), dir2 = new Vector2(), bis = new Vector2(), sa = 0.0, ea = 0.0;

                for (var k = 0; k < pathsCoords.length; ++k) {
                    var controlPoints = pathsCoords[k], pathParts = new Array(controlPoints.length - 3), p1, p2, p3 = null, p4, center;

                    for (i = 0; i < pathParts.length; i += 2) {
                        if (i + 1 < pathParts.length) {
                            p1 = new Vector2(controlPoints[i], controlPoints[i + 1]);
                            center = new Vector2(controlPoints[i + 2], controlPoints[i + 3]);
                            p4 = new Vector2(controlPoints[i + 4], controlPoints[i + 5]);

                            dir1.copy(p1).sub(center).normalize();
                            dir2.copy(p4).sub(center).normalize();

                            angCos = Math.sqrt((1 + dir1.dot(dir2)) * 0.5);
                            angSin = Math.sqrt(1 - angCos * angCos);

                            bis = new Vector2(dir1.X, dir1.Y).add(dir2).normalize().mulScalar(pathSmooth / angSin).add(center);

                            offset = pathSmooth * (angCos / angSin);

                            if (p3 !== null)
                                p1 = p3;
                            p2 = new Vector2(center.X, center.Y).add(dir1.mulScalar(offset));
                            p3 = new Vector2(center.X, center.Y).add(dir2.mulScalar(offset));

                            pathParts[i] = new PathPart(PathType.Line, p1, p2);

                            sa = (bis.Y > p2.Y ? -1 : 1) * Math.acos(dir1.copy(p2).sub(bis).mulScalar(1 / pathSmooth).X);
                            ea = (bis.Y > p3.Y ? -1 : 1) * Math.acos(dir2.copy(p3).sub(bis).mulScalar(1 / pathSmooth).X);

                            pathParts[i + 1] = new PathPart(PathType.Radial, bis, null, pathSmooth, sa, ea);
                        } else {
                            pathParts[i] = new PathPart(PathType.Line, p3 ? p3 : new Vector2(controlPoints[i], controlPoints[i + 1]), new Vector2(controlPoints[i + 2], controlPoints[i + 3]));
                        }
                    }

                    paths.push(new Path(pathParts, k));
                }

                var pc = document.createElement('canvas');
                pc.width = canvas.width;
                pc.height = canvas.height;
                this.PathsCanvas = pc;

                var pcontext = pc.getContext('2d');

                //pcolors = ['#8F04A8', '#00B25C', '#FFD300', '#FF6F00', '#01939A', '#C7007D', '#ABF000', '#009999'];
                pcontext.lineCap = 'round';
                pcontext.lineWidth = 5 / spriteManager.GlobalScale;

                pcontext.scale(spriteManager.GlobalScale, spriteManager.GlobalScale);
                pcontext.shadowBlur = 5 * spriteManager.GlobalScale;
                try {
                    pcontext.setLineDash([10 / spriteManager.GlobalScale]);
                } catch (e) {
                }
                ;
                pcontext.shadowColor = pcontext.strokeStyle = '#CCCCCC';
                pcontext.globalAlpha = 0.15;
                for (i = 0; i < paths.length; ++i) {
                    //pcontext.shadowColor = pcontext.strokeStyle = pcolors[i];
                    paths[i].render(pcontext);
                }

                this.Paths = paths;

                //create enemies
                this.Candies = new Array(this.MaxCandies);
                var candySize = new Vector2(this.CandyRadius, this.CandyRadius);
                for (i = 0; i < this.MaxCandies; ++i)
                    this.Candies[i] = new Candy(candySize);
                this.Candies[0].revive(WrapperType.Lemon, spriteManager, paths[0], this.BaseCandySpeed);
                this.Candies[1].revive(WrapperType.Apple, spriteManager, paths[1], this.BaseCandySpeed);
                this.Candies[2].revive(WrapperType.Blueberries, spriteManager, paths[2], this.BaseCandySpeed);
            }
            Level.prototype.update = function (timeDelta) {
                var i = 0, j = 0, k = 0, rnd = 0.0, candies = this.Candies, candy = null, candies = this.Candies, paths = this.Paths, candiesCount = candies.length, tap = this.InputMan.Tap, gSp = this.GSpinner, spinners = this.Spinners, sl = spinners.length, gr = this.WrapperRadius * 0.5, spRad = spinners[0].Radius + gr, gSpRad = gSp.Radius + spRad, wrappers = null;

                this.TotalTimeElapsed += timeDelta;
                if (!this.WaitingForNewWave && this.TotalTimeElapsed > this.TimeToIncreaseSpeed) {
                    this.WaitingForNewWave = true;
                }

                if (tap.justTapped) {
                    this.GSpinner.checkSpin(tap.pos);
                }

                this.GSpinner.update(0.0, timeDelta);

                var wrappedAmounts = [0, 0, 0, 0], candiesLost = 0, candiesFinishedPath = 0, wrappedCandies = 0;

                for (i = 0; i < candiesCount; ++i) {
                    candy = candies[i];
                    if (candy.FinishedPath) {
                        ++candiesFinishedPath;
                        continue;
                    }

                    if (!candy.Wrapped) {
                        if (candy.Position.collides(candy.Radius, gSp.Position, gSpRad)) {
                            for (j = 0; j < sl; ++j)
                                if (candy.Position.collides(candy.Radius * 0.5, spinners[j].Position, spRad)) {
                                    wrappers = spinners[j].Children;
                                    for (k = 0; k < wrappers.length; ++k)
                                        if (candy.Type === wrappers[k].Type && candy.Position.collides(candy.Radius * 0.5, wrappers[k].Position, gr)) {
                                            candy.Wrapped = true;
                                            candy.FinishedPath = true;
                                            ++wrappedAmounts[j];
                                            ++wrappedCandies;
                                            this.Score += this.BaseScorePerCandy * this.Wave;
                                            break;
                                        }
                                    break;
                                }
                        }
                    }

                    if (candy.update(timeDelta) && !candy.Wrapped)
                        ++candiesLost;
                }

                this.TotalWrappedAmount += wrappedCandies;
                this.CandiesCollected += wrappedCandies;

                if (this.WaitingForNewWave && candiesFinishedPath === this.MaxCandies) {
                    this.WaitingForNewWave = false;
                    ++this.Wave;
                    this.CurrentCandySpeed = this.BaseCandySpeed * (1 + 0.25 * (this.Wave - 1));
                    this.TotalTimeElapsed = 0.0;
                }

                if (candiesLost > 0) {
                    this.CandiesCollected = 0;
                    this.CandiesLost += candiesLost;
                    if (this.CandiesLost > this.CandiesToLose[this.CurrentLuck])
                        if (this.CurrentLuck === LuckLevel.Bad) {
                            //end of game
                            this.Game.showMenu();
                        } else {
                            --this.CurrentLuck;
                            this.CandiesLost = 0;
                        }
                } else {
                    if (this.CandiesCollected > this.CandiesToUp[this.CurrentLuck]) {
                        this.CandiesCollected = 0;
                        this.CurrentLuck = Math.min(this.CurrentLuck + 1, LuckLevel.Mega);
                    }
                }

                if (!this.WaitingForNewWave && candiesFinishedPath > 3) {
                    j = 0;
                    for (i = 0; i < 3; ++i) {
                        if (paths[i].LastCandy.Position.X > 150.0) {
                            if (Math.random() < 0.01)
                                for (; j < this.MaxCandies; ++j)
                                    if (candies[j].FinishedPath) {
                                        rnd = Math.random();
                                        candies[j].revive(rnd < 0.25 ? WrapperType.Apple : rnd < 0.5 ? WrapperType.Blueberries : rnd < 0.75 ? WrapperType.Lemon : WrapperType.Strawberry, this.SpriteMan, paths[i], this.CurrentCandySpeed);
                                        break;
                                    }
                        }
                    }
                }
            };

            Level.prototype.render = function (timeDelta) {
                var i = 0, candies = this.Candies, candiesCount = candies.length, context = this.Context;

                context.setTransform(1, 0, 0, 1, 0, 0);
                context.drawImage(this.PathsCanvas, 0, 0);
                for (i = 0; i < candiesCount; ++i) {
                    candies[i].render(context, timeDelta);
                }

                this.GSpinner.render(context, 0.0, timeDelta);

                //render gui elements
                context.setTransform(this.SpriteMan.GlobalScale, 0, 0, this.SpriteMan.GlobalScale, 0, 0);

                context.fillStyle = '#007FFF';
                context.font = '22px bold marker felt, comic sans ms, arial';
                context.textBaseline = 'top';
                context.shadowBlur = 0;
                context.fillText(Math.floor(this.Score), 90, 50);
                context.fillText(this.Wave, 90, 80);

                this.SpriteMan.LucksSprites[this.CurrentLuck].drawLabel(context, this.MeterPos, 1.0);
                this.MeterSize.X = (this.CandiesCollected / this.CandiesToUp[this.CurrentLuck]) * 120.0;
                this.MeterBarPos.X = 120 + this.MeterSize.X * 0.5;
                this.MeterSampler.draw(context, this.MeterBarPos, this.MeterSize);

                context.setTransform(1, 0, 0, 1, 0, 0);
            };
            return Level;
        })();
        //# sourceMappingURL=level.js.map
        ///<reference path='spinner.ts'/>
        ///<reference path='level.ts'/>
        ///<reference path='sprite_manager.ts'/>
        ///<reference path='input_manager.ts'/>
        var CandyWrapper = (function () {
            function CandyWrapper() {
                this.CurrentTime = 0.0;
                this.GameLevel = null;
                this.InputMan = null;
                this.SpriteMan = null;
                this.Canvas = null;
                this.Context = null;
                this.MenuElement = null;
                this.MenuElement = document.getElementById('menu');
                this.MenuElement.style.width = (window.innerWidth * 0.4) + 'px';
                this.MenuElement.style.height = (window.innerHeight * 0.4) + 'px';
                this.MenuElement.style.left = (window.innerWidth * 0.3) + 'px';
                this.MenuElement.style.top = (window.innerHeight * 0.1) + 'px';

                var startBtn = document.getElementById('startBtn');
                startBtn.style.fontSize = (window.innerHeight * 0.035) + 'px';
                startBtn.style.left = (window.innerWidth * 0.12) + 'px';
                startBtn.style.bottom = (window.innerHeight * 0.03) + 'px';

                document.getElementById('about').style.fontSize = (window.innerHeight * 0.02) + 'px';

                //create level
                var canvas = document.createElement('canvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                //
                //canvas.width = 1280;
                //canvas.height = 720;
                //
                canvas.style.position = 'absolute';
                canvas.style.zIndex = '0';
                canvas.style.left = canvas.style.top = '0px';
                document.body.appendChild(canvas);
                this.Canvas = canvas;
                this.Context = canvas.getContext('2d');

                var scale = Math.min(canvas.width, canvas.height) / 720.0;
                this.SpriteMan = new SpriteManager(scale, new Vector2(canvas.width, canvas.height));
                this.InputMan = new InputManager(this.Canvas, this.SpriteMan);
            }
            CandyWrapper.prototype.showMenu = function () {
                this.GameLevel = null;
                document.body.appendChild(this.MenuElement);
            };

            CandyWrapper.prototype.startNewWave = function (wave) {
                this.GameLevel = new Level(this, wave, this.Canvas, this.Context, this.SpriteMan, this.InputMan, new Vector2(1280, 720));
            };

            CandyWrapper.prototype.update = function (timeDelta) {
                this.Context.fillStyle = '#000000';
                this.Context.setTransform(1, 0, 0, 1, 0, 0);
                this.Context.fillRect(0, 0, this.Canvas.width, this.Canvas.height);
                if (this.GameLevel !== null) {
                    this.Context.drawImage(this.SpriteMan.BackgroundCanvas, 0, 0);
                    this.GameLevel.update(timeDelta);
                    this.InputMan.update();
                }
            };

            CandyWrapper.prototype.render = function (timeDelta) {
                if (this.GameLevel !== null) {
                    this.GameLevel.render(timeDelta);
                }
            };

            CandyWrapper.prototype.start = function () {
                var that = this;

                document.getElementById('startBtn').addEventListener('click', function (ev) {
                    document.body.removeChild(that.MenuElement);
                    that.startNewWave(1);
                });

                (function gameloop() {
                    window['requestAnimFrame'](gameloop);
                    var now = (self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now()) * 0.001;
                    var timeDelta = now - that.CurrentTime;
                    if (timeDelta > 0.3)
                        timeDelta = 0.0;
                    that.CurrentTime = now;
                    that.update(timeDelta);
                    that.render(timeDelta);
                })();
            };
            return CandyWrapper;
        })();

        window['requestAnimFrame'] = (function () {
            return window['requestAnimationFrame'] || window['webkitRequestAnimationFrame'] || window['mozRequestAnimationFrame'] || function (callback) {
                window.setTimeout(callback, 1000 / 60);
            };
        })();

        window.onload = function () {
            var game = new CandyWrapper();
            game.start();
        };
        //# sourceMappingURL=app.js.map
</script>
    

    
    
    
    
   </head>
<body>
    <div id="menu" class="popup">
        <div>
            <p class="about" id="about"> Press spinners to rotate them so that candies collide with wrapper with matching color.<br><br>
                 Don't forget about LuckMeter. If you miss 5 candies at level 'Bad luck' the game will end.<br><br>
                 Speed of the game will increase every 30 seconds.
            </p>
        </div>
        <div id="startBtn" class="squareBtn" onselectstart="return false">Start Game</div>
    </div>
</body>
</html>
class GraphicalMaze{constructor(t,i){this.maze=t,this.origin=new BABYLON.TransformNode("maze origin",i),this.pickingPlane=BABYLON.MeshBuilder.CreateDisc("picking disc plane",{radius:INNER_RADIUS+(t.grid.length-1)*CELL_HEIGHT},i);let e=new BABYLON.StandardMaterial("picking plane mat",i);e.alpha=.2,this.pickingPlane.material=e,this.pickingPlane.setParent(this.origin),this.pickingPlaneNormal=BABYLON.Vector3.Forward(),this.rotationLayers=initGraphicalMaze(t,i,this.origin),this.rotating=!1,this.rotatingLayer=0,this.initialRotatingVector=new BABYLON.Vector3,this.currPickVector=new BABYLON.Vector3,this.timestamp=new Date,this.isSolved=!1,i.registerBeforeRender(()=>{let t=this.timestamp;this.timestamp=new Date;let i=(this.timestamp-t)/1e3;this.update(i)})}update(t){for(let i of this.rotationLayers)i.update(t)}setRotationX(t){this.origin.rotation.x=t,this.pickingPlaneNormal.y=Math.sin(t),this.pickingPlaneNormal.z=Math.cos(t)}unhightlightLayers(){if(!this.isSolved)for(let t of this.rotationLayers)t.setWallColor(BABYLON.Color3.Black())}highlightLayer(t){if(this.isSolved)return;this.unhightlightLayers();let i=Math.floor((t-INNER_RADIUS)/CELL_HEIGHT)+1;0<i&&i<this.maze.grid.length-1&&this.rotationLayers[i].setWallColor(BABYLON.Color3.Red())}initRotateLayer(t,i){let e=Math.floor((t-INNER_RADIUS)/CELL_HEIGHT)+1;0<e&&e<this.maze.grid.length-1&&(this.rotating=!0,this.rotatingLayer=e,i.subtractToRef(this.origin.position,this.initialRotatingVector))}rotateLayer(t){t.subtractToRef(this.origin.position,this.currPickVector);let i=BABYLON.Vector3.GetAngleBetweenVectorsOnPlane(this.initialRotatingVector,this.currPickVector,this.pickingPlaneNormal);this.rotationLayers[this.rotatingLayer].rotate(i)}endRotateLayer(){this.rotating&&(this.rotating=!1,this.rotationLayers[this.rotatingLayer].endRotate())}offsets(){let t=[];for(let i of this.rotationLayers)t.push(i.offset);return t}solved(){for(let t of(this.isSolved=!0,this.rotationLayers))t.setWallColor(new BABYLON.Color3(255/256,215/256,0))}destroy(){this.origin.dispose(),this.isSolved=!1}}
!function(modules){var installedModules={};function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={i:moduleId,l:!1,exports:{}};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.l=!0,module.exports}__webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.d=function(exports,name,getter){__webpack_require__.o(exports,name)||Object.defineProperty(exports,name,{enumerable:!0,get:getter})},__webpack_require__.r=function(exports){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0})},__webpack_require__.t=function(value,mode){if(1&mode&&(value=__webpack_require__(value)),8&mode)return value;if(4&mode&&"object"==typeof value&&value&&value.__esModule)return value;var ns=Object.create(null);if(__webpack_require__.r(ns),Object.defineProperty(ns,"default",{enumerable:!0,value:value}),2&mode&&"string"!=typeof value)for(var key in value)__webpack_require__.d(ns,key,function(key){return value[key]}.bind(null,key));return ns},__webpack_require__.n=function(module){var getter=module&&module.__esModule?function(){return module.default}:function(){return module};return __webpack_require__.d(getter,"a",getter),getter},__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s="./src/index.js")}({"./src/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _noise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./noise */ \"./src/noise.js\");\n\n\nconst canvas = document.querySelector('canvas')\nconst c = canvas.getContext('2d');\nconst CW = canvas.width = document.body.offsetWidth;\nconst CH = canvas.height = document.body.offsetHeight;\nconst camPos = [canvas.width/2, canvas.height/2]\nc.translate.apply(c, camPos);\nlet fixSize = 2;\nlet D = 100032.4524;\nlet E = 3.3262;\nconst RC = [170, 170, 170];\nconst dirs = [[-1,0],[1,0], [0,1], [0,-1]];\nconst darr = ['left','right','down','up'];\nlet rnd = () => Math.random();\n\nlet START_SPAWN = false;\n\nconst CT = {};\n\nlet frame = 0;\nconst FRAME_LENGTH = 100;\nlet startTime = +(new Date());\nlet nextFrame = startTime + FRAME_LENGTH;\n\nfunction getNoise(x,y) {\n    return Object(_noise__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(E*x+D,E*y+D,E*D);\n}\n\nfunction isTile(x, y) {\n\n    if (Math.abs(x) % 60 > 57 || Math.abs(y) % 60 > 57) {\n        return isBr(x, y);\n    }\n\n    return (x >= -52 && x <= -49 && y >=8 && y <= 11) || (getNoise(x,y) < 0.2 || getNoise(x, y) > 0.8) && !(2*x>3*y) && (2*x*y<x+y+10 ) && !(x-30)*(x-30)+(y-10)*(y-10)>1;\n}\n\nfunction isBr(x, y) {\n    let ax = Math.abs(x) % 60;\n    let ay = Math.abs(y) % 60;\n    return (ax > 57 || ay > 57) && (ax % 19 > 17 || ay%19 > 17);\n}\n\nfunction isPODS(x, y) { // is part of data stream\n    return y > 8 && y < 12;\n}\n\nlet MD = {\n    type: 'S',\n};\n\nfunction enTM(text, noscale) {\n    let t = text.shift();\n    let aFT = frame + 10;\n    if (noscale) {\n        aFT = frame - 1;\n    }\n    MD = {\n        type: 'T',\n        aFT: aFT,\n        cTX: '',\n        fullText: t,\n        nextLetterTime: 0,\n        nextText: text\n    }\n};\n\nfunction Est() {\n    MD = {\n        type: 'ST',\n        fullScaleOut: frame + 5,\n        initialScale: s\n    }\n}\n\nfunction enterStageMode() {\n    MD = {\n        type: 'S'\n    }\n}\n\nfunction dsTr(r) {\n    if (frame > MD.fullScaleOut) {\n        changeScale(defaultScale);\n        enterStageMode();\n    } else {\n        let fr = (MD.fullScaleOut - frame)/5 + r/(5*5);\n        changeScale(defaultScale + fr * (MD.initialScale - defaultScale));\n    }\n}\n\nfunction dTF(r) {\n    if (MD.cTX.length === MD.fullText.length && isKey('x')) {\n        if (MD.nextText.length) {\n            enTM(MD.nextText, true);\n        } else if (!player.health) {\n            location.reload();\n        } else {\n            Est();\n        }\n        return;\n    } else if (frame <= MD.aFT) {\n        let fr = (10 - (MD.aFT - frame))/10 + r/100;\n        changeScale(defaultScale + fr * 80);\n        return;\n    } else if (MD.nextLetterTime < (frame + r) && MD.cTX.length !== MD.fullText.length) {\n        MD.cTX += MD.fullText[MD.cTX.length];\n        MD.nextLetterTime = 0;\n    }\n\n    drawTextfield(MD.cTX);\n}\n\nclass Obj {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.a = [0,0];\n        this.d = [0, 1];\n        this._s = null;\n    }\n\n    pR(scheme, t) {\n        return scheme;\n    }\n\n    render(t) {\n        let scheme = this._s(t).slice().map(s => s.slice());\n        scheme = this.pR(scheme, t);\n\n        if (this.isHit) {\n            let q = t;\n            if (q > 0.5) {\n                q = 1-q;\n            }\n            scheme = scheme.map(s => {\n                s[6] = shade(s[6], [255,0,0], q)\n                return s;\n            })\n        }\n\n        if (this.isDying) {\n            let q = t;\n            scheme = scheme.map(s => {\n                s[6] = shade(s[6], [255,100,0], t)\n                s[6][3] = t;\n                const RT = 1.5;\n                s[3] *= RT*(1+(1-t));\n                s[4] *= RT*(1+(1-t));\n                s[5] *= RT*(1+(1-t));\n                return s;\n            })\n        }\n\n        let a = this.pos(t);\n        return conv(scheme, a.x, a.y, this.d);\n    }\n\n    pos(r) {\n        let dx = (r)*this.a[0];\n        let dy = (r)*this.a[1];\n        return {x: this.x  - dx, y: this.y - dy}\n    }\n\n}\n\nclass Health extends Obj {\n    constructor(x, y) {\n        super(x,y);\n        this._s = () => getHeart();\n        this.ct = 'H';\n    }\n}\n\nclass Coin extends Obj {\n    constructor(x,y) {\n        super(x,y);\n        this._s = getCoin;\n        this.ct = 'C';\n    }\n}\n\nfunction plD(b) {\n    return Math.abs(b.x - player.x) + Math.abs(b.y - player.y);\n}\n\nclass Enemy extends Obj {\n    constructor(x, y) {\n        super(x, y);\n        this.health = 1;\n        this.isDying = false;\n        this.isHit = false;\n        this._moveRatio = 0;\n        this._fireRatio = 0;\n    }\n\n    isMoving() {\n        return this.a[0] + this.a[1] != 0;\n    }\n\n    update() {\n        this.a = [0,0];\n        if (rnd() < this._moveRatio) {\n            // decided to move ass\n            let a = [0, 0];\n            let r = rnd();\n            if (r > 0.75) {\n                a[0]++;\n            } else if(r > 0.5) {\n                a[0]--;\n            } else if (r > 0.25) {\n                a[1]++;\n            } else {\n                a[1]--;\n            }\n            if (isTile(this.x+a[0], this.y+a[1]) && !isOc(this.x+a[0], this.y+a[1])) {\n                this.x += a[0];\n                this.y += a[1];\n                this.a = a;\n                this.d = a;\n            }\n        }\n\n        if (rnd() < this._fireRatio) {\n            this.fire();\n        }\n    }\n\n    onHealthChange(h) {\n        \n    }\n\n    hit() {\n        if (--this.health <= 0) {\n            this.isDying = true;\n            explosionSound();\n        } else {\n            this.isHit = true;\n        }\n        this.onHealthChange(this.health);\n    }\n\n    fire() {\n        bullets.push(new Bullet(this.x, this.y, this.d));\n        shotSound(plD(this));\n    }    \n}\n\nlet moveLeg = (s,j, r) => {\n    j.map(i => s[i] = s[i].slice());\n    if (r < 0.5) {\n        s[j[0]][2] += r*0.2;\n        s[j[1][2]] += r*0.2;\n    } else if(r < 1) {\n        s[j[0]][2] += 0.2 - (r-0.5)*0.2;\n        s[j[1][2]] += 0.2 - (r-0.5)*0.2;\n    } else if (r < 1.5) {\n        s[2][2] += (r-1)*0.2;\n        s[3][2] += (r-1)*0.2;\n    } else {\n        s[2][2] += 0.2 - (r-1.5)*0.2;\n        s[3][2] += 0.2 - (r-1.5)*0.2;\n    }\n    return s;\n}\n\n// BOT CLASS\nclass Bot extends Enemy {\n    constructor(x, y) {\n        super(x,y);\n        this.health = 3;\n        this._s = () => getRobot(this.d);\n        this._moveRatio = 0.5;\n        this._fireRatio = 0.05;\n    }\n\n    pR(s, r) { // prerender\n\n        if (this.isMoving()) {\n            s = moveLeg(s, [0,1,2,3], r*2);\n        }\n        return s;\n    }\n}\n\nclass Agrobot extends Bot {\n    pR(s, r) {\n        let b = super.pR(s, r);\n        return b.map(x => {\n            x[6] = x[6].slice();\n            x[6][0] = 255;\n            return x;\n        });\n    }\n\n    update() {\n        this.a = [0,0];\n        let px = player.x;\n        let py = player.y;\n        let x = this.x;\n        let y = this.y;\n        if (\n            (x === px && (py -y) * ((py - 5)*this.d[1] - y) < 0) ||\n            (y === py && (px - x) * ((px - 5)*this.d[0] - x) < 0)\n        ) {\n            if (this.lastFired + 5 < frame) {\n                this.lastFired = frame;\n                this.fire();\n            }\n        } else {\n            super.update();\n        }\n    }\n}\n\nclass Swarm extends Bot {\n    constructor(x, y) {\n        super(x,y);\n        this._s = (r) => getSwarm(r);\n    }\n\n    fire() {\n        dirs.map(d => bullets.push(new Bullet(this.x, this.y, d)));\n        shotSound(plD(this));\n    }\n}\n\nclass Virus extends Enemy {\n    constructor(x,y) {\n        super(x,y);\n        this._s = getVirus;\n        this._moveRatio = 0.1;\n    }\n}\n\n\nconst ALF = [Virus];\n\nlet EN_COUNT = 10;\nlet SHIELD_ACTIVE = false;\n\nconst triggers = [\n    {\n        t: (x, y) => y === 11,\n        v: () => {\n            lead.volNext(3);\n            enTM([\n                'This is our main datastream.',\n                'All the information on the internet runs through here.',\n                'Behind this bridge you can find many unpleastant things',\n                'Viruses, bots, swarms of data',\n                'You can use your gun by pressing X',\n                'Be prepared.',\n            ]);\n            START_SPAWN = true;\n        }\n    },\n    {\n        t: (x, y) => x === -20,\n        v: () => {\n            enTM([\n                'This is a coin',\n                'It is the key to restore online connection',\n                'Do not ask me how it works, just trust me',\n                'Gather coins to unlock the way to freedom',\n                'But remember: The richer you get, the stronger are the enemies!'\n            ])\n        }\n    },\n    {\n        t: () => player.coins >= 5,\n        v: function() {\n            ALF.push(Bot);\n            EN_COUNT = 15;\n            enTM([\n                'That\\'s a good start!',\n                'Now you can face more powerful foes.',\n                'They are equiped with lasers, similiar to the one you have',\n                'Try not to get hit.'\n            ]);\n        }\n    },\n    {\n        t: () => player.coins > 60,\n        v: () => {\n            grd2 = mgd('#f00', '#600');\n        }\n    },\n    {\n        t: () => player.coins >= 20,\n        v: () => {\n            grd = mgd('#3F8', '#2EA');\n        }\n    },\n    {\n        t: () => player.coins >= 25,\n        v: () => {\n            EN_COUNT = 20;\n            SHIELD_ACTIVE = true;\n            enTM([\n                'Now you will face much more agresive bots.',\n                'They have been infected and they will try to shoot you on site.',\n                'I have upgraded your avatar with the shield',\n                'Press Z to activate it',\n                'It works in the single direction though.',\n                'Be quick or be dead!'\n            ]);\n            ALF.push(Agrobot);\n        },\n    },\n    {\n        t: () => player.coins >= 40,\n        v: () => {\n            EN_COUNT = 30;\n            enTM([\n                'You are getting rich quite fast',\n                'Actually, you are almost half way there',\n                'Gather 100 coins and you will set yourself free',\n                'But before that, the wild swarm of data can appear',\n                'It shoots in all directions with the corrupted data. This is the deadliest enemy here.',\n                'Watch out!'\n            ]);\n            ALF.push(Swarm);\n            ALF.shift();\n        }\n    },\n    {\n        t: () => !player.health,\n        v: function() {\n            enTM(['G A M E  O V E R', 'You have collected ' + player.coins + ' coins!']);\n        }\n    },\n    {\n        t: () => player.coins >= 100,\n        v: () => {\n            grd = mgd('#3F8', '#2EA');\n            enTM([\n                'Congratulations!',\n                'You have restored online connection',\n                'You are saved!',\n                'You can play in the endless mode now.',\n                'Every 10 coins will activate disco mode for a while (epilepsy warning)',\n                'Thank you for playing.',\n                'Special thanks to my inspiration, N.',\n                'Game by Kacper \"kulak\" Kula. 2018.'\n            ]);\n        }\n    },\n    {\n        t: () => player.coins > 100 && player.coins % 10 == 0,\n        d: true,\n        v: () => {\n            grd = mgd(\n                col([rnd()*255, rnd()*255,rnd()*255]),\n                col([rnd()*255, rnd()*255,rnd()*255])\n            );\n        }\n    }\n]\n\n\nfunction computeTriggers(x, y) {\n    triggers.map(t => {\n        if (t.t(x,y) && !t.used) {\n            t.v();\n            t.used = true && !t.d;\n        }\n    });\n}\n\nclass Player extends Enemy {\n    constructor(x, y) {\n        super(x, y);\n        this._nextA = [0, 0];\n        this.health = 5;\n        this.isSA = false;\n        this.coins = 0;\n        this._s = (r) => getPlayer(this.d);\n        // this._s = () => getPlayer(this.d);\n    }\n    pR(s, r) {\n\n        if (this.isMoving()) {\n            s = moveLeg(s, [1,3,2,4], r*2);\n        }\n\n        if (this.isSA) {\n            return [...s, ...SHIELD];\n        }\n        return s;\n    }\n    update() {\n        this.x += this._nextA[0];\n        this.y += this._nextA[1];\n        this.a = this._nextA;\n        if (this._nextA[0] + this._nextA[1] !== 0) {\n            this.d = this._nextA;\n        }\n        this._nextA = [0, 0];\n    }\n    move(x,y) {\n        if (isTile(this.x+x, this.y+y) && !isOc(this.x+x, this.y+y)) {\n            this._nextA = [x, y];\n            return true;\n        } else {\n            this.d = [x,y];\n        }\n\n        return false;\n    }\n\n    onHealthChange(h) {\n        let v = 0.1 * (5-h);\n        lead2.vol(v);\n        lead3.vol(v);\n    }\n\n    collect(c) {\n        if (this.isDying) {\n            return;\n        }\n        colSound();\n\n        if (c.ct === 'H' && this.health < 5) {\n            this.health++;\n            this.onHealthChange(this.health);\n        }\n        if (c.ct === 'C') {\n            this.coins++;\n        }\n    }\n}\n\nclass Camera {\n    constructor(player) {\n        this.p = player;\n        this._c = [0, 0];\n    }\n    render(r) {\n        c.translate(-this._c[0], -this._c[1]);\n        let q = gPos(this.p.pos(r).x, this.p.pos(r).y); // fixme: probably optimize\n        this._c = [-q[0], -q[1]]\n        c.translate.apply(c, this._c);\n    }\n}\n\nlet player = new Player(0, 0);\nlet camera = new Camera(player);\n\nconst BULLET_LIFETIME = 8;\nconst BULLET_SPEED = 3;\nclass Bullet {\n    constructor(x, y, a) {\n        this.x = x + a[0];\n        this.y = y + a[1];\n        this.a = a;\n        this.ttl = BULLET_LIFETIME + 1;\n        this.togc = false;\n    }\n\n    render(r) {\n        if (this.deactivated) { return; }\n        let dx = (1-r)*this.a[0]*BULLET_SPEED;\n        let dy = (1-r)*this.a[1]*BULLET_SPEED;\n        drawBullet(this.x+dx, this.y+dy);\n    }\n\n    update() {\n        this.ttl--;\n        this.x += this.a[0]*BULLET_SPEED;\n        this.y += this.a[1]*BULLET_SPEED;\n        if (!this.ttl) {\n            this.togc = true;\n        }\n    }\n}\n\nconst BAR_TIME = 0.40;\n\nconst A = new (window.AudioContext || window.webkitAudioContext)();\nvar g = A.createGain();\nvar o = A.createOscillator();\no.type = 'square';\no.connect(g);\ng.connect(A.destination);\no.start();\ng.gain.linearRampToValueAtTime(0, A.currentTime + 0.01);\n\nfunction shotSound(distance) {\n    if (distance > 10) {\n        return;\n    }\n    let t = A.currentTime;\n    g.gain.setValueAtTime(80, t);\n    o.frequency.setValueAtTime(300, t)\n    o.frequency.linearRampToValueAtTime(140, t + 0.1)\n    g.gain.linearRampToValueAtTime(0, t + 0.1);\n}\n\nvar gg = A.createGain();\nvar oo = A.createOscillator();\noo.type = 'square';\noo.connect(gg);\ngg.connect(A.destination);\noo.start();\ngg.gain.linearRampToValueAtTime(0, A.currentTime + 0.01);\n\nfunction explosionSound() {\n    let t = A.currentTime;\n    gg.gain.setValueAtTime(100, t);\n    for(var i=0;i<10;i++) {\n        // oo.frequency.linearRampToValueAtTime(140, a.currentTime + i*0.03)\n        oo.frequency.linearRampToValueAtTime(50, t + i*0.01 + 0.01)\n    }\n    // o.frequency.linearRampToValueAtTime(300, a.currentTime + 0.7)\n    gg.gain.linearRampToValueAtTime(0, t + 0.15);\n}\n\nlet colSound = (() => {\n    let g = A.createGain();\n    let o = A.createOscillator();\n    o.type = 'square';\n    o.connect(g);\n    g.connect(A.destination);\n    o.start();\n    g.gain.linearRampToValueAtTime(0, A.currentTime + 0.01);\n    return () => {\n        let t = A.currentTime;\n        g.gain.setValueAtTime(80, t);\n        o.frequency.setValueAtTime(1000, t)\n        o.frequency.linearRampToValueAtTime(1800, t + 0.1)\n        g.gain.linearRampToValueAtTime(0, t + 0.1);\n    }\n})();\n\nclass Music {\n    constructor(loop, semi, type, volume = 100) {\n        var audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n        var oscillator = audioCtx.createOscillator();\n        var g = audioCtx.createGain();\n        oscillator.type = type;\n        \n\n        this.o = oscillator;\n        this.a = audioCtx;\n        this.semi = semi*1.0595;\n\n        this.l = loop;\n        this.lastT = null;\n\n        oscillator.connect(g);\n        g.connect(audioCtx.destination);\n        g.gain.setValueAtTime(volume, audioCtx.currentTime);\n        this.g = g;\n\n        oscillator.start();\n    }\n\n    vol(x) {\n        this.g.gain.linearRampToValueAtTime(x, this.a.currentTime + 0.5);\n    }\n    \n    volNext(x) {\n        this.g.gain.linearRampToValueAtTime(x, this.lastT + 0.1);\n    }\n\n    start() {\n\n        if (!this.lastT) {\n            this.lastT = this.a.currentTime;\n        }\n\n        let t = this.lastT;\n\n        this.l.map((l) => {\n            let d = l[0]*BAR_TIME / 4;\n            if(l[1]) {\n                // this.n.o(l[1]*5, 50, t);\n                // this.n.f(t+d-0.001);\n                this.o.frequency.setValueAtTime((l[1]+this.semi)*window.Z, t); // value in hertz\n                this.o.frequency.setValueAtTime(0, t+d-0.01);\n            }\n            t+=d;\n        });\n        this.lastT = t;\n\n        const n = this.lastT - this.a.currentTime;\n        setTimeout(() =>{\n            this.start();\n        }, 1000 * n*0.95);\n        // if (this.lastT - n > 0.1) {\n        //     this.start();\n        // } else {\n        //     setTimeout(() => {\n        //         this.start();\n        //     }, 100);\n        // }\n    }\n}\n\nwindow.Z = 1;\n\nconst bass = (hz) => {\n    const x=[];\n    for(var i=0;i<8;i++) {\n        x.push([2, hz])\n        x.push([2, -1]);\n    }\n    return x;\n}\n\nfunction rep(x, times) {\n    let y = [];\n    for(let i=0;i<times;i++) {\n        y.push(x);\n    }\n    return y;\n}\n\nlet flat = a => a.reduce((c, v) => c.concat(v));\n\nlet makeMusic = m => m.map(n => [n[0], 27.6*Math.pow(2, (n[1]-21)/12)])\n\nlet DR = 4;\nlet DX = 2;\n\nlet NEW_BASS = makeMusic(flat([\n    rep([DR, 24], 8),\n    rep([DR, 32], 8),\n    rep([DR, 34], 8),\n    rep([DR, 30], 8)\n]));\n\nlet NEW_LEAD = makeMusic([\n    [DX, 60],\n    [DX, 63],\n    [DX, 68],\n    [DX, 63],\n    [DX, 60], // rep\n    [DX, 63],\n    [DX, 68],\n    [DX, 63],\n\n    [DX, 55],\n    [DX, 60],\n    [DX, 65],\n    [DX, 63],\n    [DX, 70],\n    [DX, 63],\n    [DX, 67],\n    [DX, 63],\n\n    [DX, 60], // rep\n    [DX, 63],\n    [DX, 68],\n    [DX, 63],\n\n    [DX, 70],\n    [DX, 65],\n    [DX, 65],\n    [DX, 63]\n\n])\n\nconst bs = new Music(NEW_BASS, 0, 'sawtooth', 1);\nbs.start();\n\nconst lead = new Music(NEW_LEAD, 0, 'sine', 0);\nlead.start();\n\nconst lead2 = new Music(NEW_LEAD, -5, 'square', 0);\nlead2.start();\n\nconst lead3 = new Music(NEW_LEAD, +5, 'square', 0);\nlead3.start();\n\nfunction isOc(x, y) {\n    return [...bots,player].reduce((a,b) => a || b.x == x && b.y == y, 0);\n\n}\n\n// bulelts\nlet bullets = [];\n\n// Make bots\nlet bots = []\n\nlet pups = [new Coin(-22, 4)];\n\n\n\nconst defaultScale = 80;\nlet s = defaultScale;\nfunction changeScale(newS) {\n    s = newS;\n}\nconst ALPHA = 0.2;\n\nwindow.S = 2;\n\nfunction gPos(x, y, dx=0, dy=0) {\n    return [\n        (x - y)*s + dx,\n        (x + y)*s/window.S + dy\n    ]\n}\n\nfunction drawTop(x, y, color, w=1, h=1, dx = 0, dy = 0, borderColor) {\n    c.beginPath();\n    c.moveTo.apply(c, gPos(x,y, dx, dy))\n    c.lineTo.apply(c, gPos(x-w, y, dx, dy));\n    c.lineTo.apply(c, gPos(x-w,y-h, dx, dy));\n    c.lineTo.apply(c, gPos(x, y-h, dx, dy));\n    c.closePath();\n    c.lineWidth = fixSize;\n    c.fillStyle = color;\n    c.fill();\n    if (borderColor) {\n        c.strokeStyle = borderColor;\n        c.stroke();\n    }\n}\n\nfunction drawRight(x, y, color, w, h, dx = 0, dy = 0, borderColor = color) {\n    c.beginPath();\n    c.moveTo.apply(c, gPos(x,y, dx, dy));\n    let p = gPos(x, y-w, dx, dy);\n    c.lineTo.apply(c, p);\n    p[1] += h*s;\n    c.lineTo.apply(c, p);\n    p = gPos(x, y, dx, dy);\n    p[1] += h*s;\n    c.lineTo.apply(c, p, dx, dy);\n    c.closePath();\n    c.fillStyle = color;\n    c.fill();\n    if (borderColor) {\n        c.lineWidth = fixSize;\n        c.strokeStyle = borderColor;\n        c.stroke();\n    }\n}\n\nfunction drawLeft(x, y, color, w, h, dx = 0, dy = 0, borderColor = color) {\n    c.beginPath();\n    c.moveTo.apply(c, gPos(x,y, dx, dy));\n    let p = gPos(x-w, y, dx, dy);\n    c.lineTo.apply(c, p);\n    p[1] += h*s;\n    c.lineTo.apply(c, p);\n    p = gPos(x,y, dx, dy);\n    p[1] += h*s;\n    c.lineTo.apply(c,p);\n    c.closePath();\n\n    c.fillStyle = color;\n    c.fill();\n    if (borderColor) {\n        c.lineWidth = fixSize;\n        c.strokeStyle = borderColor;\n        c.stroke();\n    }\n}\n\nfunction col(c) {\n    if (c.length === 3) {\n        return 'rgb(' + c.join(',') + ')';\n    } else {\n        return 'rgba(' + c.join(',') + ')';\n    }\n}\n\nfunction shade(c, sh, alpha) {\n    var al = c.length > 3 ? c[3] : 1;\n    return [\n        c[0] + (sh[0] - c[0]) * alpha,\n        c[1] + (sh[1] - c[1]) * alpha,\n        c[2] + (sh[2] - c[2]) * alpha,\n        al\n    ]\n}\n\nfunction darken(color, alpha) {\n    return shade(color, [0,0,0], alpha);\n}\n\nfunction lighten(color, alpha) {\n    return shade(color, [255,255,255], alpha);\n}\n\n\nfunction dBx(x, y, color = [128,128,128], w = 1, d = 1, h = 1, raise = 0, calculateFromTop = false, borderColor, ddx = 0, ddy = 0) {\n    let dy = ddy;\n    if (calculateFromTop) {\n        dy = -h*s;\n    }\n    dy -= raise * s;\n    drawTop(x, y, col(color), w, d, ddx, dy, borderColor);\n    drawLeft(x, y, col(lighten(color, ALPHA)), w, h, ddx, dy, borderColor);\n    drawRight(x, y, col(darken(color, ALPHA)), d, h, ddx, dy, borderColor);\n}\n\nconst cM = 5;\n\nfunction clear() {\n    c.clearRect(-canvas.width*cM, -canvas.height*cM, canvas.width*cM*2, canvas.height*cM*2);\n}\n\nfunction conv(rec, x, y, dir, dx = 0, dy = 0) { // [x, y, z, w, d, h, col]\n    if (dir[1] < 0) {\n        rec = rec.map(x => {\n            x = x.slice();\n            x[1] = 1-x[1]\n            return x;\n        });\n    }\n\n    if(dir[0] < 0) {\n        rec = rec.map(x => {\n            x = x.slice();\n            let t = x[0];\n            x[0] = 1 - x[1];\n            x[1] = t;\n            t = x[3];\n            x[3] = x[4];\n            x[4] = t;\n            return x;\n        })\n    }\n    // FIXME: check if it could be simplified\n    if(dir[0] > 0) {\n        rec = rec.map(x => {\n            x = x.slice();\n            let t = x[0];\n            x[0] = x[1];\n            x[1] = t;\n            t = x[3];\n            x[3] = x[4];\n            x[4] = t;\n            return x;\n        })\n    }\n\n    // const f = (x) => {\n    //     const p = gPos(x[0] + x[3]/2, x[1]+x[4]/2);\n    //     return p[2] + p[0] + p[1];\n    // }\n\n    // const orderFn = (a, b) => {\n    //     let res = [-1,-1,1];\n    //     for(var i=0;i<3;i++) {\n    //         if (a[0+i] - a[3+i] >= b[0+i] + b[3+i]) {\n    //             return res[i];\n    //         } else if (b[0+i] - b[3+i] >= a[0+i] + a[3+i]) {\n    //             return -res[i];\n    //         }\n    //     }\n    //     return -1;\n    // }\n\n    // const f = x => x[0];\n\n    // rec = rec.sort((a,b) => -f(a) + f(b));\n\n\n    rec.map(r => {\n        // here comes the magic\n        let xx = r[0];\n        let yx = r[1];\n        let z = r[2];\n        let w = r[3];\n        let d = r[4];\n        let h = r[5];\n        let col = r[6];\n\n\n        // if (dir[1] < 0) {\n        //     yx = 1-yx;\n        // }\n        // if (dir[0] < 0) {\n        //     let ax = 1 - xx;\n        //     xx = 1 - yx;\n        //     yx = ax;\n\n        //     ax = w;\n        //     w = d;\n        //     d = ax;\n        // }\n\n        // if (dir[0] > 0) {\n        //     let ax = 1 - xx;\n        //     xx = yx;\n        //     yx = ax;\n\n        //     ax = w;\n        //     w = d;\n        //     d = ax;\n        // }\n\n        // console.log(dir);\n\n        // console.log('DRAW', x - xx + w/2, y - yx + d/2, col, w, d, h, z - h/2, false);\n        dBx(x - xx + w/2, y - yx + d/2, col, w, d, h, z + h/2, false, false, dx, dy);\n    })\n}\n\nconst PC = [200, 180, 150]\n\nfunction getPlayer(dir) {\n    const p = [\n        [0.65, 0.4, 0.4, 0.05, 0.2,0.05, [90,70,200]],\n        [0.35, 0.425, 0.05, 0.05, 0.2, 0.05, PC],\n        [0.35, 0.5, 0.15, 0.05, 0.05, 0.2, PC],\n\n        [0.55, 0.425, 0.05, 0.05, 0.2, 0.05, PC],\n        [0.55, 0.5, 0.15, 0.05, 0.05, 0.2, PC],\n\n        // belly\n        [0.5, 0.5, 0.4, 0.2, 0.2, 0.4, [90, 70, 150]],\n        // head\n        [0.5, 0.5, 0.7, 0.3, 0.3, 0.3, PC],\n        [0.5, 0.5, 0.85, 0.3, 0.3, 0.01, [140, 70, 45]],\n\n        // hand\n        [0.35, 0.4, 0.4, 0.05, 0.2,0.05, [90,70,200]],\n        // eye\n\n        // [0.5, 0.4, 1.0, 0.2, 0.001, 0.1, [255, 0, 0]]\n    ]\n    let dirs = [[dir[0], dir[1]], [dir[1], dir[0]]];\n    if (dir[0] > 0) {\n        dirs=[[1,0],[0,1]];\n    }\n    if (dir[1] < 0) {\n        dirs = [[-1, 0], [0,1]];\n    }\n    if (dir[0] < 0) {\n        dirs = [[-1, 0], [0, 1]];\n    }\n    if (dir[0]+dir[1] > 0) {\n       p.push([0.45, 0.35, 0.7, 0.05, 0.001, 0.05, [0, 0, 0]]);\n       p.push([0.6, 0.35, 0.7, 0.05, 0.001, 0.05, [0, 0, 0]]);\n        p.push([0.525, 0.35, 0.6, 0.03, 0.001, 0.03, [200, 60, 50]]);\n    }\n    for(let d of dirs) {\n        for(var i=0;i<10;i++) {\n            let siz = 0.03;\n            let len = (Math.sin(i+1.4)+1)*0.05+0.05;\n            p.push([\n                0.5 + !!d[0]*(-0.15 + 0.0015+ i*0.03) - 0.15 * d[1],\n                0.5 + !!d[1]*(-0.15 + 0.0015 + i*0.03) - 0.15 * d[0],\n                0.87 - len/2,\n                0.01,\n                0.03,\n                len,\n                [140,70,45]\n            ])\n        }\n    }\n    return p;\n}\n\nfunction getHeart(isOff) {\n    let x = [];\n    let color = [200, 0, 0];\n    if (isOff) {\n        color = [100, 100, 100, 0.8];\n    }\n    for(let i=0;i<5;i++) {\n        x.push([\n                0.5,\n                0.5,\n                0.05*i,\n                0.05+i*0.1,\n                0.1,\n                0.05,\n                color\n        ])\n    }\n    for(let i=5;i<8;i++) {\n        x.push([\n            0.35,\n            0.5,\n            0.05*i,\n            0.25 - (i-5)*0.05,\n            0.1,\n            0.05,\n            color\n        ])\n        x.push([\n            0.65,\n            0.5,\n            0.05*i,\n            0.25 - (i-5)*0.05,\n            0.1,\n            0.05,\n            color\n        ])\n    }\n    return x;\n}\n\nfunction getSwarm(r) {\n    const s = [];\n    for(let j=0;j<5;j++) {\n        for(let i=0;i<10;i++) {\n            s.push([\n                0.5 + Math.sin(2*Math.PI/10*i)*0.3,\n                0.5 + Math.cos(2*Math.PI/10*i)*0.3,\n                0.5 + Math.cos(2*Math.PI/10*j)*0.3,\n                0.05,\n                0.05,\n                0.05,\n                [200-24*i, 40*j, j*i*0.5, 0.5]\n            ])\n        }\n    }\n    return s.map(x => {\n        x = x.slice();\n        x[3] -= Math.sin(2*Math.PI*r)*0.3;\n        x[2] += rnd()*0.4;\n        x[6] = x[6].slice();\n        x[6][0] += rnd()*10;\n        x[6][1] += rnd()*20;\n        x[6][2] -= rnd()*10;\n        return x;\n    })\n}\n\nfunction getVirus(r) {\n    r = getMultiframePosition(15, frame, r);\n    let v = [];\n    for(let i=0;i<8;i++) {\n        v.push([\n            0.5 + Math.sin(2*Math.PI/8*i)*0.4*Math.cos(2*Math.PI*r),\n            0.5 + Math.cos(2*Math.PI/8*i)*0.4*Math.sin(2*Math.PI*r),\n            0.5,\n            0.1,\n            0.1,\n            0.1,\n            [40, 80+i*20, 200-i*10]\n        ])\n    }\n    return v;\n}\n\nfunction getCoin(r) {\n    let v = [];\n    for(let i=1;i<8;i++) {\n        v.push([\n            0.5,\n            0.5,\n            0.05*i,\n            0.05+0.2*Math.sin(Math.PI*(i/8)),\n            0.1,\n            0.05,\n            [200,200,0]\n        ])\n    }\n    return v;\n}\n\nfunction getMultiframePosition(multi, frame, r) {\n    return (frame % multi)/multi + r / (multi*multi);\n}\n\n\n// const ROBOT_s = [\n//     // leg ??\n//     [0.3, 0.4, RC, 0.1, 0.3, 0.1],\n//     [0.3, 0.6, RC, 0.1, 0.1, 0.5, 0, true],\n    \n//     // arm 2\n//     [0.8, 0.3, darken(RC, 0.2), 0.1, 0.3, 0.1, 0.6, true],\n//     [0.8, 0.2, [20, 20, 20], 0.1, 0.1, 0.1, 0.6, true],\n//     [0.8, 0.5, darken(RC, 0.2), 0.1, 0.1, 0.2, 0.7, true],\n\n//     // body\n//     [0.7, 0.4, RC, 0.1, 0.3, 0.1],\n//     [0.7, 0.6, RC, 0.1, 0.1, 0.5, 0, true],\n//     [0.3, 0.4, RC, 0.6, 0.6, 0.6, 0.5, true],\n\n//     [0.4, 0.5, RC, 0.4, 0.4, 0.4, 1.1, true], // head\n//     [0.45, 0.49, [0,0,0], 0.3, 0.01, 0.2, 1.2, true], // face\n\n//     // eyes:\n//     [0.75, 0.59, [0,0,200], 0.05, 0.01, 0.05, 1.2, true], // eye1\n//     [0.6, 0.59, [0,0,200], 0.05, 0.01, 0.05, 1.2, true], // eye 2\n\n//     // arm 1\n//     [0.2, 0.4, darken(RC, 0.2), 0.1, 0.3, 0.1, 0.6, true],\n//     [0.2, 0.3, [20, 20, 20], 0.1, 0.1, 0.1, 0.6, true],\n//     [0.2, 0.6, darken(RC, 0.2), 0.1, 0.1, 0.2, 0.7, true]\n// ];\nfunction getRobot(d) { // FIXME: add arm\n        let x= [\n        // [0.5,0.5,0.5, 1, 1, 1, RC],\n        // [0.5, 0.5, 1.25, 0.5, 0.5, 0.5, [255, 0, 0]]\n        [0.3, 0.4, 0.05, 0.1, 0.3, 0.1, RC],\n        [0.3, 0.5, 0.3, 0.1, 0.1, 0.4, RC],\n        // arm\n        [0.8, 0.5, 0.65, 0.1, 0.1, 0.2, darken(RC, 0.2)],\n        [0.8, 0.3, 0.6, 0.1, 0.3, 0.1, darken(RC, 0.2)],\n        [0.8, 0.2, 0.6, 0.1, 0.1, 0.1, [20, 20, 20]],\n\n        [0.6, 0.4, 0.05, 0.1, 0.3, 0.1, RC],\n        [0.6, 0.5, 0.3, 0.1, 0.1, 0.4, RC],\n\n        // belly\n        [0.5, 0.5, 0.6, 0.4, 0.4, 0.6, RC],\n        // head\n        [0.5, 0.5, 1.0, 0.2, 0.2, 0.2, RC]\n        ];\n        if (d[0]>0||d[1]>0) x.push([0.5, 0.4, 1.0, 0.2, 0.001, 0.1, [255, 0, 0]])\n\n        return x.concat([[0.2, 0.5, 0.65, 0.1, 0.1, 0.2, darken(RC, 0.2)],\n        [0.2, 0.3, 0.6, 0.1, 0.3, 0.1, darken(RC, 0.2)],\n        [0.2, 0.2, 0.6, 0.1, 0.1, 0.1, [20, 20, 20]]]);\n}\n\nconst SHIELD = [\n    [0.5, 0.1, 0.5, 1, 0.01, 1, [50, 50, 200, 0.5]]\n]\n\nfunction drawBullet(x, y, opacity = 1) {\n    dBx(x - 0.2, y - 0.2, [200, 50, 50, opacity], 0.1, 0.1, 0.1, 0.6, true);\n}\n\nlet mgd = (d, e) => {\n    let g = c.createLinearGradient(camPos[0] - CW/2, camPos[1] - CH/2, camPos[0] - CW/2, camPos[1] + CH);\n    g.addColorStop(0, d);\n    g.addColorStop(1, e);\n    return g;\n}\nlet grd = mgd('#8f27a8','#33B');\nlet grd2 = mgd('rgba(28, 206,52, 0.5)', 'rgba(226, 217,3, 0.5)');\n\nfunction splitText(text, size=40) {\n\n    let t = text.split(' ');\n    let res=[];\n    let curr = '';\n\n    t.map(t => {\n        if ((curr + t).length >= size) {\n            res.push(curr + ' ' + t);\n            curr = '';\n        } else {\n            curr += ' ' + t;\n        }\n    })\n    if (curr.length > 0) {\n        res.push(curr);\n    }\n    return res;\n}\n\nfunction drawTextfield(text, r = 0, dx=0, dy=0, noFrame, size=20) {\n    const poz = gPos(player.pos(r).x, player.pos(r).y)\n    const layers = [\n        [-5, -1, 'red'],\n        [5, 3, 'green'],\n        [-3, 3, 'blue'],\n        [0,0,'#000']\n    ];\n    c.font = size + 'px Courier New';\n\n    text = splitText(text);\n    \n    let textWid = Math.max.apply(Math, text.map(t => c.measureText(t).width));\n\n    const padding = 20;\n    const hei = (size+10) * text.length + 2*padding - 10;\n    const wid = textWid + 2*padding;\n    if (!noFrame) {\n        layers.map(l => {\n            c.beginPath();     \n            c.rect(poz[0]-wid/2+dx + l[0], dx +poz[1] - padding + l[1] - hei/2, wid, hei);\n            c.fillStyle = l[2];\n            c.fill();\n        });\n    }\n\n    text.map((t,i) => {\n\n        const ls = [[-2, 0, 'red'], [3, 1, 'green'], [2, -1, 'blue'],[0,0, 'white']];\n        ls.map(l => {\n            c.fillStyle = l[2];\n            c.fillText(t, dx+poz[0]-wid/2 + padding + l[0], dy+poz[1] + 20 + l[1] + i*30 - hei/2);\n        });\n    });\n}\n\n\nfunction drawMap(r) {\n    const mapSize = 10;\n    for(let i=player.x-mapSize;i<player.x+mapSize;i++) {\n        for(let j=player.y-mapSize;j<player.y+mapSize;j++) {\n            if (isTile(i,j)) {\n                if (isBr(i,j)) {\n                    dBx(i,j,[100, 100, 100, 0.9], 1, 1, 0.8, 0, false, grd2);\n                } else {\n                    dBx(i,j,[0, 0, 0, 0.9], 1, 1, 0.8, 0, false, grd2);\n                }\n            } else if (isPODS(i,j)) {\n                const f = ((frame%10)/10 + r/100);\n                dBx(i+0.4+f, j+0.4+Math.sin(f*Math.PI)*0.2, [50,255,0, 0.8], 0.2, 0.2, 0.2, false, false, 'rgba(0,0,0,0)');\n                dBx(i+0.7+f*2, j+0.2*0.356, [20,255,50, 1], 0.2, 0.2, 0.2, false, false, 'rgba(0,0,0,0)');\n            }\n        }\n    }\n}\n\nfunction drawPlayer(r) {\n    player.render(r); // FIXME: move shield rendering to class\n}\n\nlet stars = [];\nfor(let i=0;i<300;i++) {\n    stars.push([\n        getNoise(i*5.3423, i*0.64323),\n        getNoise(i*10, i*12),\n        getNoise(i * 23.41, i*414.421)\n    ])\n}\n\nfunction drawBackground(r) {\n    c.fillStyle=grd;\n    const sm = gPos(player.pos(r).x, player.pos(r).y, -CW/2, -CH/2);\n    c.fillRect(sm[0], sm[1], CW, CH);\n    for(var s of stars) {\n        c.beginPath();\n        c.arc(sm[0] + CW/2 + s[0]*CW, sm[1] + CH/2 + s[1]*CH,1.5 + 0.5*s[2],0,2*Math.PI);\n        c.fillStyle = '#FFF';\n        c.fill();\n    }\n\n\n    c.beginPath();\n    let sunX = sm[0] + CW/2 + CW/3 - player.pos(r).y*0.5;\n    let sunY = sm[1] + CH/3;\n    let sunR =  CH/4;\n\n    c.beginPath();\n    c.arc(sunX, sunY, sunR,0,2*Math.PI);\n\n\n    const sung = c.createLinearGradient(sunX,sunY-sunR,sunX,sunY+sunR);\n    sung.addColorStop(0, 'rgb(255, 255, 30, 0.9)');\n    sung.addColorStop(1, 'rgba(200, 30, 70, 0.8)');\n\n    c.fillStyle = sung;\n    c.fill();\n    const slices=20;\n    let j = 0;\n\n\n    for(var i=-5;i<slices;i++) {\n        j++;\n        if(i%2==0) { continue }\n        c.beginPath();\n        c.rect(sunX-sunR,sunY+sunR/slices*i*j*0.1,2*sunR,sunR/slices*j*0.2);\n        c.fillStyle=grd;\n        c.fill();\n    }\n}\n\nfunction drawEnemies(r) {\n    pups.map(p => p.render(r));\n    bots.map(b => b.render(r));\n}\n\nfunction drawBullets(r) {\n    bullets.map(b => b.render(r));\n}\n\nfunction computeCollisions() {\n    bullets.map(b => {\n        [...bots, player].map(bot => {\n            for(var i=0;i<BULLET_SPEED;i++) {\n                if (b.x + b.a[0]*i === bot.x && b.y + b.a[1]*i === bot.y) {\n                    // console.log('HIT');\n                    if (!(bot.isSA && bot.d[0]*b.a[0] + bot.d[1]*b.a[1] < 0)) {\n                        bot.hit();\n                    }\n                    b.togc = true;\n\n                }\n            }\n        })\n    })\n    pups = pups.filter(p => {\n        if (p.x === player.x && p.y === player.y) {\n            player.collect(p);\n            return false;\n        }\n        return true;\n    })\n}\n\nfunction gc() {\n    bots = bots.filter(b => !b.togc);\n    bullets = bullets.filter(b => !b.togc);\n}\n\nfunction recomputeFrame() {\n    let now = +(new Date());\n    if (now > nextFrame) {\n        if (MD.type === 'S') {\n            bots.map(b => b.isHit = false)\n            player.isHit = false;\n            bots = bots.filter(b => {\n                if (b.isDying) {\n                    let r = rnd();\n                    if(r < (5-player.health)*0.05) {\n                        pups.push(new Health(b.x, b.y));\n                    } else if(r < 0.7) {\n                        pups.push(new Coin(b.x, b.y));\n                    }\n                }\n                if (plD(b) > 40) {\n                    return false;\n                }\n                return !b.isDying\n            });\n            pups = pups.filter(p => plD(p) < 40);\n            computeCollisions();\n            gc();\n\n            if (bots.length < EN_COUNT && START_SPAWN) {\n                let x = Math.floor(player.x + 5 + rnd() * 10);\n                let y = Math.floor(player.y+ 5 + rnd()*15);\n                if (isTile(x, y) && !isOc(x, y)) {\n                    let i = Math.floor(ALF.length * rnd());\n                    let C = ALF[i];\n                    bots.push(new C(x, y));\n                }\n            }\n\n            // updating all\n            bots.map(b => b.update());\n            bullets.map(b => b.update());\n\n            player.update();\n        }\n        nextFrame = now + FRAME_LENGTH;\n        frame++;\n        computeTriggers(player.x, player.y);\n        updateKeys()\n        // FIXME: collision detection probably.\n    }\n\n    return (nextFrame - now) / FRAME_LENGTH;\n}\n\nlet weirdAnimEndFrame = 0;\nlet weirdAnimSize = 0;\nlet weirdColor = 0;\nlet weirdAnimLen = 4;\n\nlet weirdFreezeFrame = 0;\nlet weirdFrame = null;\nlet weirdFrameX = 0;\nlet weirdFrameY = 0;\n\nfunction drawPostprocess(r) {\n    const pos = gPos(player.pos(r).x, player.pos(r).y, -CW/2, -CH/2);\n    let cn = CH;\n    let f = getMultiframePosition(10, frame, r);\n    for(var i=0;i<cn;i++) {\n        if (i%2 == 0) { continue; }\n\n        c.beginPath();\n        c.fillStyle = 'rgba(0,0,0,'+ 0.6 + ')';\n        c.rect(pos[0], pos[1] + CH/cn*i + frame%2, CW, CH/cn);\n        c.fill();\n    }\n\n    if(rnd() > 0.9899 && weirdAnimEndFrame < frame) {\n        weirdAnimLen = 2 + Math.floor(rnd() * 10); \n        weirdAnimEndFrame = frame + weirdAnimLen;\n        weirdAnimSize = CH/80*rnd();\n        weirdColor = Math.round(rnd()*4);\n    }\n\n    if (weirdAnimEndFrame > frame) {\n        let clr = [0,0,0, 0.5];\n        if (weirdColor > 0) {\n            clr[weirdColor-1] = 200;\n        }\n        c.fillStyle = 'rgba(' + clr.join(',') + ')';\n        c.rect(pos[0], pos[1] + CH * (1 -(weirdAnimEndFrame-frame)/weirdAnimLen), CW, weirdAnimSize);\n        c.fill();\n    }\n\n    // Weird freeze\n    if (rnd() > 0.95 && weirdFreezeFrame < frame) {\n        weirdFreezeFrame = frame + 2;\n        let posX = rnd() * CW*0.9;\n        let posY = rnd() * CH*0.9;\n        let width = Math.min(CW-posX, CW/3);\n        let height = Math.min(CH-posY, CH/4);\n        weirdFrame = c.getImageData(posX, posY, width, height);\n        weirdFrameX = posX + (rnd()-0.5)*2*3;\n        weirdFrameY = posY + (rnd()-0.5)*2*6;\n    }\n\n    if (weirdFreezeFrame > frame) {\n        c.putImageData(weirdFrame, weirdFrameX, weirdFrameY);\n    }\n}\n\nfunction drawHud(r) {\n    const pos = gPos(player.pos(r).x, player.pos(r).y, -CW/2, -CH/2);\n    const height = 50;\n    const padding = 20;\n    c.beginPath();\n    c.rect(pos[0], pos[1] + CH - s*3/2, CW, s*3/2);\n    c.fillStyle = 'rgba(0,0,0,0.5)';\n    c.fill();\n    for(var i=0;i<5;i++) {\n        conv(getHeart(i>=player.health), player.pos(r).x, player.pos(r).y, [1,0], -CW/2  + i*s+s, CH/2);\n    }\n    conv(getCoin(r), player.pos(r).x, player.pos(r).y, [1,0], +CW/2 - 2*s, CH/2);\n    drawTextfield(''+player.coins, r, CW/2 - s/4*5, CH/2 - 20, true, 40);\n}\n\nlet gp = null;\n\n// window.addEventListener(\"gamepadconnected\", function(e) {\n//     gp = navigator.getGamepads()[e.gamepad.index];\n//     console.log('gamepad', gp);\n// });\n\nfunction rGP(key) {\n    let gp = navigator.getGamepads()[0];\n    if (!gp) {\n        return;\n    }\n    if (key === 'x') {\n        return gp.buttons[1].pressed;\n    }\n    if (key === 'z') {\n        return gp.buttons[0].pressed;\n    }\n    return darr.reduce((a, d,i) => a || (key === 'arrow'+d && dirs[i][0] === gp.axes[0] && dirs[i][1] === gp.axes[1]), 0);\n}\n\nfunction isKey(key) {\n    return CT[key] || rGP(key);\n}\n\nfunction updateKeys() {\n    if(isKey('x')) {\n        player.fire();\n    }\n    player.isSA = SHIELD_ACTIVE && isKey('z');\n    darr.map((x,i) => { if(isKey('arrow'+x)) player.move(dirs[i][0], dirs[i][1])});\n}\n\n\nfunction draw() {\n    let fr = recomputeFrame();\n    let gfr = fr;\n    if (MD.type !== 'S') {\n        fr = 0;\n    }\n    clear();\n    camera.render(fr);\n    drawBackground(fr);\n    drawMap(fr);\n    drawEnemies(fr);\n    drawBullets(fr);\n    drawPlayer(fr);\n    if (MD.type === 'S') {\n        drawHud(fr);\n    }\n\n    if (MD.type === 'T') {\n        dTF(gfr);\n    }\n\n    if (MD.type === 'ST') {\n        dsTr(gfr);\n    }\n\n    drawPostprocess(gfr);\n\n    requestAnimationFrame(draw);\n}\n\ndraw();\nenTM([\n    'Welcome to the cyberspace' + ' '.repeat(35) + '(PRESS X to continue)',\n    'Game by' + ' '.repeat(10) + 'kulak',\n    'You must be the new one.',\n    'There has been a blackout in your world and everything went offline',\n    \"You've been transfered here to restore the connection\",\n    'Now you have to fight your way through the cyberspace!',\n    'It\\'s usually a calm place but we are experiencing glitch invasion right now so please proceed with caution.',\n    'Head straight and try to cross the river',\n    'Good luck!'\n]);\n\ndocument.addEventListener('keydown', (e) => {\n    CT[e.key.toLowerCase()] = 1;\n});\n\ndocument.addEventListener('keyup', (e) => {\n    CT[e.key.toLowerCase()] = 0;\n})\n\n//# sourceURL=webpack:///./src/index.js?")},"./src/noise.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\nlet d = (g,x,y,z) => g[0]*x + g[1]*y + g[2]*z; // dot\nlet m = (a, b, t) => (1.0-t)*a + t*b; // mix\nlet f = (t) => t*t*t*(t*(t*6.0-15.0)+10.0); // fade\n\nlet g = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0], \n[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1], \n[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]]; \nlet p = [];\nfor (var i=0; i<256; i++) {\n  p[i] = Math.floor(Math.abs(Math.sin(i*432.4224))*256);\n}\nlet perm = []; \nfor(var i=0; i<512; i++) {\n  perm[i]=p[i & 255];\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (function(x, y, z) { \n  // Find unit grid cell containing point \n  var X = Math.floor(x); \n  var Y = Math.floor(y); \n  var Z = Math.floor(z); \n  \n  // Get relative xyz coordinates of point within that cell \n  x = x - X; \n  y = y - Y; \n  z = z - Z; \n  \n  // Wrap the integer cells at 255 (smaller integer period can be introduced here) \n  X = X & 255; \n  Y = Y & 255; \n  Z = Z & 255;\n\n  // Compute the fade curve value for each of x, y, z \n  var u = f(x); \n  var v = f(y); \n  var w = f(z); \n\n  // Simplify the code. - just generate all the permutations and compute the gradient from there.\n  const gx = [\n    [0,0,0],\n    [0,0,1],\n    [0,1,0],\n    [0,1,1],\n    [1,0,0],\n    [1,0,1],\n    [1,1,0],\n    [1,1,1]\n  ]\n\n  let e = gx.map(gr => {\n    return d(g[perm[X+gr[0]+perm[Y+gr[1]+perm[Z+gr[2]]]] % 12], x-gr[0], y - gr[1], z - gr[2]);\n  })\n  var nx00 = m(e[0], e[4], u); \n  var nx01 = m(e[1], e[5], u); \n  var nx10 = m(e[2], e[6], u); \n  var nx11 = m(e[3], e[7], u); \n  // Interpolate the four results along y \n  var nxy0 = m(nx00, nx10, v); \n  var nxy1 = m(nx01, nx11, v); \n  // Interpolate the two last results along z \n  var nxyz = m(nxy0, nxy1, w); \n\n  return nxyz; \n});;\n\n//# sourceURL=webpack:///./src/noise.js?')}});
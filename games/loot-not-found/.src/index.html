<html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<style>
		:root {
			--button-width: 15vmin;
		}
		* {
			background-color: #202020;
			margin: 0;
			padding: 0;
			touch-action: none;
		}

		.hidden {
			visibility: hidden;
		}

		.directionbutton {
			position: absolute;
			width: var(--button-width);
			padding-top: calc(var(--button-width) / 2);
			padding-bottom: calc(var(--button-width) / 2);;
			z-index: 2;
			border: 1px solid rgba(75,75,75,0.7);
			background-color: rgba(25,25,25,0.7);
			user-select: none;
		}

		.directionbutton:active {
			border: 2px solid rgba(150,150,150,0.7);
			background-color: rgba(50,50,50,0.7);
		}

		.gamebutton {
			position: absolute;
			font: 2vmin Arial;
			width: var(--button-width);
			padding-top: calc(var(--button-width) / 2 - 1vmin);
			padding-bottom: calc(var(--button-width) / 2 - 1vmin);;
			z-index: 2;
			border: 2px solid rgba(75,75,75,0.7);
			border-radius: 100%;
			background-color: rgba(25,25,25,0.7);
			color: white;
			text-align: center;
			user-select: none;
		}

		.gamebutton:active {
			border: 2px solid rgba(150,150,150,0.7);
			background-color: rgba(50,50,50,0.7);
		}

		.up{
			left: calc(var(--button-width) * 1.5);
			top: calc(100% - var(--button-width) * 4);
		}
		.right{
			left: calc(var(--button-width) * 2.5);
			top: calc(100% - var(--button-width) * 3);
		}
		.down{
			left: calc(var(--button-width) * 1.5);
			top: calc(100% - var(--button-width) * 2);
		}
		.left {
			left: calc(var(--button-width) / 2);
			top: calc(100% - var(--button-width) * 3);
		}

		.interactbutton {
			left: calc(100% - var(--button-width) * 2.5);
			top: calc(100% - var(--button-width) * 2);
		}

		.itemsbutton {
			left: calc(100% - var(--button-width) * 1.5);
			top: calc(100% - var(--button-width) * 3);
		}
	</style>
	<script>
		function updateCamera(){panX=Math.floor(player.x-w/2),clamp(panX,0,Math.floor(w/2)),panY=Math.floor(player.y-h/2),clamp(panY,0,Math.floor(h/2))}function objectInView(x,y,w,h){return pointInView(x-w,y-h)||pointInView(x+w,y-h)||pointInView(x+w,y+h)||pointInView(x-w,y+h)}function pointInView(x,y){let padding=TILE_SIZE;return x>panX-TILE_SIZE&&y>panY-TILE_SIZE&&x<w+panX+TILE_SIZE&&y<h+panY+TILE_SIZE}function resizeCanvas(e){canvas.width=w=window.innerWidth,canvas.height=h=window.innerHeight}function objectTileCollision(object){let hit=!1,nearTiles=tilesNearPosition(object.x,object.y);for(tile of nearTiles){let groundType=currentLevel.getType(0,tile),airType=currentLevel.getType(1,tile);if(groundType>GRND||airType>GRND){let tileRect=getTileCollider(tile),collision=checkCollision(object,tileRect);if(collision.hit)if(1==substanceTypes[groundType].state){let delta;hit=!0,correctCollision(object,new Vector2(object.x-tileRect.x,object.y-tileRect.y),collision.overlap)}else object.tileEffect&&object.tileEffect(airType)}}return hit}function continuousTileCollision(object){let hit=!1,aabbSize=new Vector2(Math.abs(object.velocity.x)+2*object.size,Math.abs(object.velocity.y)+2*object.size),increment=object.size/4,subDivisions=Math.floor(aabbSize.length/increment),velIncrement=object.velocity.normalize().multiply(increment),op=object.position;for(let a=0;a<=subDivisions;a++){object.position=object.position.add(velIncrement);let nearTiles=tilesNearPosition(object.x,object.y);for(tile of nearTiles){let groundType=currentLevel.getType(0,tile),airType=currentLevel.getType(1,tile);if(groundType>GRND||airType>GRND){let tileRect=getTileCollider(tile),collision=checkCollision(object,tileRect);if(collision.hit)if(1==substanceTypes[groundType].state){let delta;hit=!0,correctCollision(object,new Vector2(object.x-tileRect.x,object.y-tileRect.y),collision.overlap)}else object.tileEffect&&object.tileEffect(airType)}}if(hit)break}return hit}function correctCollision(object,delta,overlap){Math.abs(delta.x)>Math.abs(delta.y)?delta.y=0:delta.x=0,(delta=delta.normalize()).x*=overlap.x,delta.y*=overlap.y,object.position=object.position.add(delta),object.velocity=object.velocity.add(delta),object.velocity=object.velocity.multiply(FRICTION)}function getTileCollider(tileIndex){let x=tileIndex%currentLevel.width,y=Math.floor(tileIndex/currentLevel.width),tileRect;return{x:x*TILE_SIZE+TILE_SIZE/2,y:y*TILE_SIZE+TILE_SIZE/2,type:"rect",width:TILE_SIZE,height:TILE_SIZE}}function checkCollision(col1,col2){let collision={};if(Math.abs(col1.x-col2.x)>col1.size+col2.size||Math.abs(col1.y-col2.y)>col1.size+col2.size)return collision.hit=!1,collision;if("circle"==col1.type)switch(col2.type){case"circle":collision=circleOverlap(col1,col2);break;case"rect":collision=circleRectOverlap(col1,col2)}else if("rect"==col1.type)switch(col2.type){case"circle":collision=circleRectOverlap(col2,col1);break;case"rect":collision=aabbOverlap(col1,col2)}return collision}function circleOverlap(circle1,circle2){let distX=circle1.x-circle2.x,distY=circle1.y-circle2.y,dist,width;return Math.hypot(distX,distY)<=circle1.radius+circle2.radius?{hit:!0,overlap:{x:distX,y:distY}}:{hit:!1,overlap:0}}function circleRectOverlap(circle,rect){let distX=circle.x-rect.x,distY=circle.y-rect.y,ang=Math.atan2(distY,distX)+Math.PI,width=rect.width/2+Math.abs(Math.cos(ang)*circle.radius),height=rect.height/2+Math.abs(Math.sin(ang)*circle.radius);return Math.abs(distX)<width&&Math.abs(distY)<height?{hit:!0,overlap:new Vector2(width-Math.abs(distX),height-Math.abs(distY))}:{hit:!1,overlap:0}}function aabbOverlap(rect1,rect2){let distX=Math.abs(rect1.x-rect2.x),distY=Math.abs(rect1.y-rect2.y),width=(rect1.width+rect2.width)/2,height=(rect1.height+rect2.height)/2;return distX<=width&&distY<=height?{hit:!0,overlap:new Vector2(width-distX,height-distY)}:{hit:!1,overlap:0}}const MIN_ROOM_SIZE=8,ROOM_SIZE=16,TILE_SIZE=16,PARTICLE_SIZE=TILE_SIZE/4,AIR_RESISTANCE=.96,FRICTION=.95,NOEFF=-1,GRND=0,CNCRT=1,WOOD=2,METAL=3,GLASS=4,GOLD=5,WATER=6,BLOOD=7,OIL=8,ICE=9,FIRE=10,SMOKE=11,GAS=12,STEAM=13,SHOCK=14,BMIST=15,E_STM=16,ALL_SUBST=[GRND,1,2,3,4,6,10,11,12,13,14],WALL_SUBST=[1,2,3],SOLID_SUBST=[1,2,3,4],EMPTY_SET=new Set,SOLID_SUBST_SET=new Set(SOLID_SUBST),GAS_SUBST_SET=new Set([10,11,12,13,14]),ALL_SUBST_SET=new Set(ALL_SUBST),substanceTypes=[];substanceTypes[GRND]={life:1/0,quantity:1,state:0,effects:new Set([6,8,7,9,11,13,12])},substanceTypes[1]={life:100,quantity:1,state:1,effects:EMPTY_SET,ondeath:-1},substanceTypes[2]={life:50,quantity:1,state:1,effects:new Set([10]),ondeath:-1},substanceTypes[3]={life:1/0,quantity:1,state:1,effects:new Set([14]),ondeath:-1},substanceTypes[4]={life:25,quantity:1,state:1,effects:EMPTY_SET,ondeath:-1},substanceTypes[6]={life:100,quantity:16,state:2,effects:new Set([11,13,14,12,6,7]),ondeath:-1},substanceTypes[8]={life:200,quantity:8,state:2,effects:new Set([11,13,12,10,8,6]),ondeath:-1},substanceTypes[7]={life:100,quantity:64,state:2,effects:new Set([11,13,14,12,7]),ondeath:-1},substanceTypes[9]={life:100,quantity:1,state:2,effects:new Set([11,13,14,12]),ondeath:6},substanceTypes[10]={life:60,quantity:1,state:4,effects:new Set([2,13,6]),ondeath:11},substanceTypes[11]={life:60,quantity:32,state:3,effects:new Set([11,GRND,6,7,8,10,13]),ondeath:-1},substanceTypes[12]={life:60,quantity:60,state:3,effects:new Set([12,GRND,6]),ondeath:-1},substanceTypes[13]={life:120,quantity:64,state:3,effects:new Set([13,GRND,6]),ondeath:-1},substanceTypes[14]={life:60,quantity:60,state:4,effects:EMPTY_SET,ondeath:-1};const substColors=new Array(substanceTypes.length).fill("#000000");substColors[GRND]="#202020",substColors[1]="#454545",substColors[2]="#402920",substColors[3]="#8585a0",substColors[5]="#ffca00",substColors[4]="#9090ff",substColors[6]="#4040b0",substColors[7]="#330000",substColors[9]="#f0f0ff",substColors[10]="#d03510",substColors[11]="#121212",substColors[12]="#00ff00",substColors[13]="#b0b0cf",substColors[14]="#ffff00";const effectMatrix=new Array(substanceTypes.length).fill(null).map(()=>new Array(substanceTypes.length).fill(-1));effectMatrix[6][10]=13,effectMatrix[10][6]=13,effectMatrix[10][GRND]=11,effectMatrix[10][11]=11,effectMatrix[10][13]=13,effectMatrix[13][10]=13;const SOUND_EFFECTS={destroytile:[.75,.01,100,.02,,.6,4,1.33,-.6,,,,.015,,40,.2,,.5],lootpickup:[.3,,700,,.02,.16,,1.78,,,606,.05,,,.2,.04,,.51,,.11],hammerhit:[,,400,,,0,2,.8,,,,,,4,-.5,.8,,.55,.05],firebomb:[.5,.02,356,.15,,.4,4,1.33,-.6,,,,,,,.1,,.2,.3],boom:[,,1e3,,.02,.3,4,3,.8,.5,,,,,12,.7],door:[,,100,,.1,.2,1,2,,,100,.01,.05,.9,50,,,.4,.1,1],pickup:[.2,,1e3,,,.09,,.65,,49,,,,,120,,,.12,.02,.08],drop:[,,880,.1,,.25,,3,,,200,.2,,,59.9,,,.9],select:[.3,,1600,,,,,,,,-1600,.01,,,60],use:[,,440,.01,,,,,,,220,.012,,,60]};let canvas,ctx,w,h,panX,panY,particles,gameState=0;class GameObject{_durability=100;size=TILE_SIZE;position=new Vector2(0,0);rotation=new Vector2(0,1);velocity=new Vector2(0,0);type="rect";physics="dynamic";constructor(x,y){this.position.x=x,this.position.y=y}onUse(){}onInteract(){player.pickup(this)}draw(x,y){}drawDurability(x,y){if(0==this.durability){ctx.strokeStyle="red",ctx.beginPath();let length=this.size/3;ctx.moveTo(x-length,y-length),ctx.lineTo(x+length,y+length),ctx.moveTo(x+length,y-length),ctx.lineTo(x-length,y+length),ctx.stroke()}}drawLabel(x,y){colorText(this.constructor.name,x,y-2*TILE_SIZE,"white","16px Arial")}onCollision(withObject){}get width(){return this.size}get height(){return this.size}get x(){return this.position.x}get y(){return this.position.y}set x(value){this.position.x=value}set y(value){this.position.y=value}get durability(){return this._durability}set durability(value){this._durability=clamp(value,0,100)}get interactCollider(){return this}}class LootPiece extends GameObject{active=!0;value=4;constructor(x,y){super(x,y),this.size=TILE_SIZE/2}onInteract=()=>{};onCollision(withObject){this.active&&withObject==player&&(player.loot+=this.value,this.active=!1,zzfx(...SOUND_EFFECTS.lootpickup))}draw(x,y){if(this.active&&pointInView(x,y)){let tile=tileAtCoords(x,y),tileType=currentLevel.getType(1,tile),color=tileType>GRND?averageHexColors([substColors[tileType],substColors[5]]):substColors[5];colorRect(x,y,this.size,this.size,color,!0)}}set durability(v){}}class Hammer extends GameObject{constructor(x,y){super(x,y),this.size=2*TILE_SIZE}onUse(){let hit=0,ix,iy,index,tiles=tilesNearIndex(tileAtCoords(player.x+player.rotation.x*this.size,player.y+player.rotation.y*this.size));for(let tile of tiles){let type=currentLevel.getType(0,tile);SOLID_SUBST_SET.has(type)&&(currentLevel.addLife(0,tile,-25),hit++)}hit&&(zzfx(...SOUND_EFFECTS.hammerhit),this.durability-=10)}onCollision(withObject){withObject==player&&player.interactables.push(this)}draw(x,y){let tile=tileAtCoords(x,y),tileType=currentLevel.getType(1,tile);ctx.translate(x,y);let color=tileType>GRND?averageHexColors([substColors[tileType],substColors[2]]):substColors[2];colorRect(0,0,this.size/6,this.size,color,!0),color=tileType>GRND?averageHexColors([substColors[tileType],substColors[3]]):substColors[3],colorRect(-this.size/3,-this.size/2,this.size/1.5,this.size/4,color),this.drawDurability(0,0),ctx.translate(-x,-y)}}class FireBomb extends GameObject{armed=!1;constructor(x,y){super(x,y),this.size=TILE_SIZE}onUse=useThrowable;onCollision(withObject){if(withObject!=player||this.armed){if(this.armed){let tiles=tilesNearPosition(this.x,this.y);for(let tile of tiles)currentLevel.spawnTile(tile,8),currentLevel.spawnTile(tile,10);zzfx(...SOUND_EFFECTS.firebomb);let index=currentLevel.objects.indexOf(this);index>=0&&currentLevel.objects.splice(index,1)}}else player.interactables.push(this)}draw(x,y){let capHeight=this.size/3;colorRect(x-this.size/4,y-this.size/2,this.size/2,capHeight,"red"),colorRect(x-this.size/4,y-this.size/2+capHeight,this.size/2,this.size-capHeight,"olive")}get width(){return this.size/2}}class Grenade extends GameObject{_blastRadius=6;armed=!1;type="circle";constructor(x,y){super(x,y)}onUse=useThrowable;onCollision(withObject){if(withObject!=player||this.armed){if(withObject!=player&&this.armed){let tile=tileAtCoords(this.x,this.y);for(let y=1-this._blastRadius;y<this._blastRadius;y++)for(let x=1-this._blastRadius;x<this._blastRadius;x++){if(Math.abs(x)+Math.abs(y)>this._blastRadius)continue;let checkTile=tile+y*currentLevel.width;3!=currentLevel.getType(0,checkTile)&&(Math.floor(checkTile/currentLevel.width)==Math.floor((checkTile+=x)/currentLevel.width)&&(currentLevel.setType(1,checkTile,10),currentLevel.addLife(0,checkTile,-200)))}let boomCollider={x:this.x,y:this.y,type:"circle",radius:TILE_SIZE+this._blastRadius*TILE_SIZE};if(currentLevel.objects.forEach(e=>{if(e!=this&&checkCollision(e,boomCollider).hit){let delta=new Vector2(e.x-this.x,e.y-this.y);delta.length=boomCollider.radius/delta.length*TILE_SIZE/2,e.velocity=e.velocity.add(delta),e.durability-=100,null!=e.armed&&(e.armed=1)}}),checkCollision(player,boomCollider).hit){let delta=new Vector2(player.x-this.x,player.y-this.y);delta.length=boomCollider.radius/delta.length*TILE_SIZE/2,player.velocity=player.velocity.add(delta),player.hp-=50}zzfx(...SOUND_EFFECTS.boom);let index=currentLevel.objects.indexOf(this);index>=0&&currentLevel.objects.splice(index,1)}}else player.interactables.push(this)}draw(x,y){ctx.fillStyle="olive",ctx.beginPath(),ctx.arc(x,y,this.radius,0,2*Math.PI,!1),ctx.fill()}get radius(){return this.size/2}}class Balloon extends GameObject{_blastRadius=4;armed=!1;type="circle";constructor(x,y){super(x,y)}onUse=useThrowable;onCollision(withObject){if(withObject!=player||this.armed){if(this.armed){let tiles=tilesNearPosition(this.x,this.y);for(let tile of tiles)currentLevel.spawnTile(tile,6);zzfx(...SOUND_EFFECTS.firebomb);let index=currentLevel.objects.indexOf(this);index>=0&&currentLevel.objects.splice(index,1)}}else player.interactables.push(this)}draw(x,y){ctx.fillStyle="blue",ctx.beginPath(),ctx.arc(x,y,this.radius,0,2*Math.PI,!1),ctx.fill()}get radius(){return this.size/2}}class Door extends GameObject{size=TILE_SIZE;physics="static";locked=!1;_open=!1;constructor(x,y){super(x,y)}onInteract(){if(!this.durability)return;let key=player.items[player.held];if(key&&key.constructor.name==Key.name&&key.onUse(),!this.locked){let hit=checkCollision(player,this).hit;this.open?hit||(this.open=!1,zzfx(...SOUND_EFFECTS.door)):(this.open=!0,zzfx(...SOUND_EFFECTS.door))}}onCollision(whichObject,collision){if(whichObject==player){player.interactables.push(this);let overlap=collision.overlap;if(!this.open&&(Math.abs(overlap.x)>this.size/2||Math.abs(collision.overlap.y)>this.size/2)&&(overlap=checkCollision(whichObject,this).overlap)){let delta;correctCollision(whichObject,new Vector2(whichObject.x-this.x,whichObject.y-this.y),overlap)}}}draw(x,y){this.open?ctx.fillStyle=averageHexColors([substColors[2],substColors[GRND]]):ctx.fillStyle=substColors[2],ctx.strokeStyle=substColors[3],ctx.beginPath(),ctx.rect(x-this.size/2,y-this.size/2,this.size,this.size),ctx.fill(),ctx.stroke()}drawLabel(x,y){let locked=!this.open&&this.locked?" (Locked)":"";colorText(this.constructor.name+locked,x,y-2*TILE_SIZE,"white","16px Arial")}get interactCollider(){return{x:this.x,y:this.y,type:"rect",width:2.5*this.size,height:2.5*this.size}}get open(){return this._open||0==this.durability}set open(value){this._open=value}}class Key extends GameObject{constructor(x,y){super(x,y)}onCollision(whichObject){whichObject==player&&player.interactables.push(this)}onUse(){let interactable=player.interactables[0];if(interactable&&interactable.constructor.name==Door.name&&interactable.locked){interactable.locked=!1;let index=player.items.indexOf(this);index>=0&&(player.items[index]=null)}return!1}draw(x,y){colorRect(x-this.size/6,y-this.size/4,this.size/3,this.size,substColors[5]),colorRect(x-this.size/3,y+this.size/4,this.size/1.5,this.size/2)}set durability(v){}}function useThrowable(){if(this.position.x=player.position.x+player.rotation.x*(player.size+this.size),this.position.y=player.position.y+player.rotation.y*(player.size+this.size),this.velocity=player.velocity.add(player.rotation.multiply(10)),!objectTileCollision(this)){this.armed=!0,currentLevel.objects.push(this);let index=player.items.indexOf(this);return index>=0&&(player.items[index]=null),!0}return!1}const ITEMS=[Hammer,FireBomb,Grenade,Balloon,Key];function colorText(text,x,y,color,font,align,baseline){font&&(ctx.font=font),align&&(ctx.textAlign=align),baseline&&(ctx.textBaseline=baseline),color&&(ctx.fillStyle=color),ctx.fillText(text,x,y)}function colorRect(x,y,w,h,color,center){let xOffset=center?-w/2:0,yOffset=center?-h/2:0;color&&(ctx.fillStyle=color),ctx.fillRect(x+xOffset,y+yOffset,w,h)}function colorCircle(x,y,r,color,fill,stroke){ctx.fillStyle=color,ctx.beginPath(),ctx.arc(x,y,r,0,2*Math.PI,!1),fill&&ctx.fill(),stroke&&ctx.stroke()}function setShadow(color,blur,oX,oY){color&&(ctx.shadowColor=color),blur&&(ctx.shadowBlur=blur),oX&&(ctx.shadowOffsetX=oX),oY&&(ctx.shadowOffsetY=oY)}function resetShadow(){ctx.shadowColor="",ctx.shadowBlur=0,ctx.shadowOffsetX=0,ctx.shadowOffsetY=0}function averageHexColors(colors){if(1==colors.length)return colors[0];let total=[0,0,0];for(let color of colors){let parsed=hexColorToInts(color);total[0]+=parsed[0],total[1]+=parsed[1],total[2]+=parsed[2]}total[0]&&(total[0]=clamp(Math.floor(total[0]/colors.length),0,255)),total[1]&&(total[1]=clamp(Math.floor(total[1]/colors.length),0,255)),total[2]&&(total[2]=clamp(Math.floor(total[2]/colors.length),0,255));let string="#";for(let num of total)num<16&&(string+="0"),string+=num.toString(16);return string}function hexColorToInts(color){let subst=[color.slice(1,3),color.slice(3,5),color.slice(5,7)];return[parseInt(subst[0],16),parseInt(subst[1],16),parseInt(subst[2],16)]}function addHexColors(color1,color2){let subst1=[color1.slice(1,3),color1.slice(3,5),color1.slice(5,7)],subst2=[color2.slice(1,3),color2.slice(3,5),color2.slice(5,7)],sums=[];for(let c=0;c<subst1.length;c++){let sum=parseInt(subst1[c],16)+parseInt(subst2[c],16);sum=clamp(sum,0,255),sums.push(sum)}return"#"+sums[0].toString(16)+sums[1].toString(16)+sums[2].toString(16)}function screenTransition(fromDraw,toDraw,callback){const timeLimit=30;null==screenTransition.timer&&(screenTransition.timer=0),null==screenTransition.direction&&(screenTransition.direction=1);let draws=[toDraw,fromDraw];if(screenTransition.timer+=screenTransition.direction,screenTransition.timer>30)screenTransition.direction=-1;else if(screenTransition.direction<0&&screenTransition.timer<0)return screenTransition.timer=screenTransition.direction=void 0,void callback();draws[clamp(screenTransition.direction,0,1)](),ctx.globalAlpha=screenTransition.timer/30,colorRect(0,0,w,h,"black"),ctx.globalAlpha=1}const controls={u:0,d:0,l:0,r:0,items:0,interact:0},controlsLastFrame={u:0,d:0,l:0,r:0,items:0,interact:0};function setControl(key,to){65!=key&&37!=key||(controls.l=to),68!=key&&39!=key||(controls.r=to),87!=key&&38!=key||(controls.u=to),83!=key&&40!=key||(controls.d=to),69==key&&(controls.items=to),32==key&&(controls.interact=to)}function control(){let av=new Vector2(0,0);if(controls.items){let currentHeld=player.held;controls.u&&(player.held=0),controls.l&&(player.held=1),controls.r&&(player.held=2),controls.d&&(player.held=3),controls.interact&&player.drop(player.held),player.held!=currentHeld&&zzfx(...SOUND_EFFECTS.select)}else controls.l&&(av.x-=1),controls.r&&(av.x+=1),controls.u&&(av.y-=1),controls.d&&(av.y+=1),controls.interact&&!controlsLastFrame.interact&&(player.interactables[0]?player.interact():player.use());for(let key in controls)controls.hasOwnProperty(key)&&(controlsLastFrame[key]=controls[key]);return player.isDead?null:av.normalize()}this.addEventListener("keydown",e=>setControl(e.which,1)),this.addEventListener("keyup",e=>setControl(e.which,0));class SubstanceLayer{constructor(size){this._stride=3,this.grid=new Array(size*this._stride),this.grid.fill(0)}spawnTile(index,type){let typeIndex=index*this._stride;this.grid[typeIndex]==type&&substanceTypes[type]?this.grid[++typeIndex]+=substanceTypes[type].quantity*Math.random()/2:(this.grid[typeIndex++]=type,substanceTypes[type]&&(this.grid[typeIndex++]=substanceTypes[type].quantity),substanceTypes[type]&&(this.grid[typeIndex]=substanceTypes[type].life))}getType(levelIndex){return this.grid[levelIndex*this._stride]}setType(levelIndex,type){this.grid[levelIndex*this._stride]=type}getQuantity(levelIndex){return this.grid[levelIndex*this._stride+1]}setQuantity(levelIndex,value){this.grid[levelIndex*this._stride+1]=value}getLife(levelIndex){return this.grid[levelIndex*this._stride+2]}setLife(levelIndex,value){this.grid[levelIndex*this._stride+2]=value}resetTile(index){let tileIndex=index*this._stride;this.grid[tileIndex++]=GRND,this.grid[tileIndex++]=GRND,this.grid[tileIndex]=GRND}draw(){for(let e=0;e<this.length;e++){let type=this.getType(e);if(type<=0)continue;let x=e%currentLevel.width,y=(e-x)/currentLevel.width*TILE_SIZE;x*=TILE_SIZE,pointInView(x,y)&&colorRect(x,y,TILE_SIZE,TILE_SIZE,substColors[type])}}get length(){return this.grid.length/this._stride}}class LevelExit extends GameObject{size=16*TILE_SIZE/4;type="rect";physics="static";constructor(x,y){super(x,y)}onCollision(whichObject){whichObject==player&&whichObject.interactables.push(this)}onInteract(){this.locked||(update.transition=[draw,drawWinScreen,()=>{gameState=3,update.transitioning=!1}],update.transitioning=!0)}draw(){if(objectInView(this.x,this.y,this.size,this.size)){let x,y;colorRect(this.x,this.y,this.size,this.size,substColors[2],!0),colorRect(this.x,this.y-this.size*(3/8),this.size,this.size/4,averageHexColors([substColors[3],substColors[GRND]]),!0),colorRect(this.x,this.y,this.size/2,this.size/2,"black",!0),colorRect(this.x,this.y+this.size*(3/8),this.size/2,this.size/4,averageHexColors([substColors[2],substColors[GRND]]),!0),ctx.strokeStyle=averageHexColors([substColors[3],substColors[GRND]]),ctx.lineWidth=2,ctx.strokeRect(this.x-this.size/2,this.y-this.size/2,this.size,this.size),colorText("EXIT",this.x,this.y-this.size/2+this.size/7,"#ffca00",this.size/3+"px Arial","center","middle")}}drawLabel(x,y){let locked;colorText("Exit"+(this.locked?" (Locked)":""),x,y-this.size/2-16,"white","16px Arial")}get locked(){return player.loot<404}get radius(){return this.size}}class GameLevel{_layers=[];objects=[];width=0;height=0;start=new Vector2(TILE_SIZE+16*TILE_SIZE/2,TILE_SIZE+16*TILE_SIZE/2);exit=new LevelExit(0,TILE_SIZE+16*TILE_SIZE/4);constructor(width,height){this.width=width,this.height=height,this._layers[0]=new SubstanceLayer(width*height),this._layers[1]=new SubstanceLayer(width*height),this.start.x=this.exit.x=width*TILE_SIZE/2,this.start.y=height*TILE_SIZE-16*TILE_SIZE/4-TILE_SIZE,this.objects.push(this.exit)}spawnTile(index,type){let layer=substanceTypes[type].state<3?0:1,groundType=this.getType(0,index),airType=this.getType(1,index);substanceTypes[groundType].effects.has(type)&&(airType<=GRND||substanceTypes[airType].effects.has(type))?this._layers[layer].spawnTile(index,type):elementInteraction(type,index)}getType(layer,index){return this._layers[layer].getType(index)}setType(layer,index,type){this._layers[layer].setType(index,type)}addLife(layer,index,life){let cLife=this.getLife(layer,index);this.setLife(layer,index,cLife+life)}getLife(layer,index){return this._layers[layer].getLife(index)}setLife(layer,index,life){this._layers[layer].setLife(index,life)}addQuantity(layer,index,quantity){let cQuant=this.getQuantity(layer,index);this.setQuantity(layer,index,cQuant+quantity)}getQuantity(layer,index){return this._layers[layer].getQuantity(index)}setQuantity(layer,index,quantity){this._layers[layer].setQuantity(index,quantity)}resetTile(layer,index){this._layers[layer].resetTile(index)}draw(){let yMin=Math.floor(panY/TILE_SIZE),yMax=yMin+Math.floor(canvas.height/TILE_SIZE)+1;yMin=clamp(yMin,0,currentLevel.height),yMax=clamp(yMax,0,currentLevel.height-1);let xMin=Math.floor(panX/TILE_SIZE),xMax=xMin+Math.floor(canvas.width/TILE_SIZE)+1,tile;xMin=clamp(xMin,0,currentLevel.height),xMax=clamp(xMax,0,currentLevel.height-1);for(let y=yMin;y<=yMax;y++){tile=y*currentLevel.width;for(let x=xMin;x<=xMax;x++){let air=this.getType(1,tile+x),ground=this.getType(0,tile+x),color;air>GRND?color=ground>GRND?averageHexColors([substColors[air],substColors[ground]]):substColors[air]:ground>GRND&&(color=substColors[ground]),color&&colorRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE,color)}}this.drawStart()}drawLayer(layer){this._layers[layer].draw()}drawStart(){let SIZE=16*TILE_SIZE/4;objectInView(this.start.x,this.start.y,SIZE,SIZE)&&(colorRect(this.start.x,this.start.y,SIZE,SIZE,substColors[2],!0),colorRect(this.start.x,this.start.y-SIZE*(3/8),SIZE,SIZE/4,averageHexColors([substColors[3],substColors[GRND]]),!0),colorRect(this.start.x,this.start.y,SIZE/2,SIZE/2,averageHexColors([substColors[4],substColors[1]]),!0),colorRect(this.start.x,this.start.y+SIZE*(3/8),SIZE/2,SIZE/4,averageHexColors([substColors[2],substColors[1]]),!0),ctx.strokeStyle=averageHexColors([substColors[3],substColors[GRND]]),ctx.lineWidth=2,ctx.strokeRect(this.start.x-SIZE/2,this.start.y-SIZE/2,SIZE,SIZE),colorText("START",this.start.x,this.start.y-SIZE/2+SIZE/7,"white",SIZE/4+"px Arial","center","middle"))}get length(){return this.width*this.height}}function generateLevel(width,height){let rooms=[],index=0;for(let y=0;y<height;y++)for(let x=0;x<width;x++){if(0==x||0==y||x==width-1||y==height-1)rooms.push([0,0,0,0]);else{let width=Math.floor(8+8*Math.random()),height=Math.floor(8+8*Math.random()),left=Math.floor(Math.random()*(16-width)),top=Math.floor(Math.random()*(16-height));type=WALL_SUBST[Math.floor(Math.random()*WALL_SUBST.length)],rooms.push([left,top,left+width,top+height,type])}index++}return generateTileGrid(rooms,width,height)}function generateTileGrid(rooms,width,height){let lootLeft=404,level=new GameLevel(16*width,16*height),roomIndex=0;for(let y=0;y<height;y++){for(let x=0;x<width;x++){let room=width*y+x;if(0==rooms[room][3]){roomIndex+=16;continue}let left=rooms[room][0],top=rooms[room][1],right=rooms[room][2],bottom=rooms[room][3],wallType=rooms[room][4],openings=createOpenings(rooms[room]),di=Math.floor(Math.random()*openings.length),doorOpening=openings[di];2==wallType?spawnItem(roomIndex,rooms[room],level):generateLoot(roomIndex,rooms[room],level);for(let ry=top;ry<bottom;ry++)for(let rx=left;rx<right;rx++){let tileIndex=roomIndex+16*ry*width+rx;if(Math.abs(rx-doorOpening[0])<=1&&Math.abs(ry-doorOpening[1])<=1){if(rx==doorOpening[0]&&ry==doorOpening[1]){let dx=tileIndex%level.width,dy=(tileIndex-x)/level.width,door=new Door(Math.floor(dx)*TILE_SIZE,Math.floor(dy)*TILE_SIZE);(2!=wallType||Math.random()>.8)&&(door.locked=!0),door.x+=TILE_SIZE/2,door.y+=TILE_SIZE/2,level.objects.push(door)}}else rx!=left&&ry!=top&&rx!=right-1&&ry!=bottom-1||(level.setType(0,tileIndex,wallType),level.setQuantity(0,tileIndex,1),level.setLife(0,tileIndex,substanceTypes[wallType].life))}for(let o=0;o<openings.length;o++)if(3!=wallType&&o!=di){let window=openings[o],wIndex=roomIndex+16*window[1]*width+window[0];level.setType(0,wIndex,4),level.setLife(0,wIndex,substanceTypes[4].life)}roomIndex+=16}roomIndex+=16*width*16}return sealLevel(level)}function generateLoot(topLeftIndex,room,level){let left=topLeftIndex%level.width,top=(topLeftIndex-left)/level.width;for(let y=room[1]+1;y<room[3]-1;y++)for(let x=room[0]+1;x<room[2]-1;x++)if(Math.random()>.9){let lx=(left+x)*TILE_SIZE,ly=(top+y)*TILE_SIZE,loot=new LootPiece(Math.floor(lx),Math.floor(ly));loot.x+=loot.size,loot.y+=loot.size,level.objects.push(loot)}}function spawnItem(topLeftIndex,room,level){let left=topLeftIndex%level.width,top=(topLeftIndex-left)/level.width,x=left+(room[0]+room[2])/2,y=top+(room[1]+room[3])/2,item=new(ITEMS[Math.floor(Math.random()*ITEMS.length)])(x*TILE_SIZE,y*TILE_SIZE);level.objects.push(item)}function createOpenings(room){let doors=[];return doors[0]=[room[0],Math.floor((room[1]+room[3])/2)],doors[1]=[room[2]-1,Math.floor((room[1]+room[3])/2)],doors[2]=[Math.floor((room[0]+room[2])/2),room[1]],doors[3]=[Math.floor((room[0]+room[2])/2),room[3]-1],doors}function sealLevel(level){let index=0;for(let y=0;y<level.height;y++)for(let x=0;x<level.width;x++)0!=x&&0!=y&&x!=level.width-1&&y!=level.height-1||(level.setType(0,index,3),level.setQuantity(0,index,1),level.setLife(0,index,substanceTypes[3].life)),index++;return level}function tilesNearPosition(x,y){let index;return tilesNearIndex(tileAtCoords(x,y))}function tilesNearIndex(index){let tiles=[];for(let y=-1;y<2;y++)for(let x=-1;x<2;x++){let checkTile=index+currentLevel.width*y;Math.floor(checkTile/currentLevel.width)==Math.floor((checkTile+=x)/currentLevel.width)&&(checkTile<0||checkTile>currentLevel.length||tiles.push(checkTile))}return tiles}function tileAtCoords(x,y){return Math.floor(Math.floor(y/TILE_SIZE)*currentLevel.width+Math.floor(x/TILE_SIZE))}function nearTileColors(layer,x,y){let tiles=tilesNearPosition(x,y),colors=[];for(tile of tiles){let type=currentLevel.getType(layer,tile);type>GRND&&colors.push(substColors[type])}return colors}function enableTouch(){console.log("Touch Controls Enabled"),document.querySelectorAll(".hidden").forEach(e=>e.classList.remove("hidden")),canvas.removeEventListener("touchstart",enableTouch)}function newGame(){particles.reset(),currentLevel=generateLevel(9,9),player.reset(),player.position.x=currentLevel.start.x,player.position.y=currentLevel.start.y}function update(){if(null==update.transition&&(update.transition=new Array(3)),null==update.transitioning&&(update.transitioning=!1),update.transitioning)screenTransition(update.transition[0],update.transition[1],update.transition[2]);else switch(gameState){case 0:drawMainMenu(),controls.interact&&(newGame(),updateCamera(),update.transition=[drawMainMenu,draw,()=>{gameState=1,update.transitioning=!1}],update.transitioning=!0);break;case 1:physicsUpdate(),updateCamera(),draw();break;case 2:physicsUpdate(),draw(),drawGameOver(),controls.interact&&(update.transitioning=!0,update.transition=[()=>{draw(),drawGameOver()},drawMainMenu,()=>{gameState=0,update.transitioning=!1}]);break;case 3:drawWinScreen(),controls.interact&&(update.transitioning=!0,update.transition=[drawWinScreen,drawMainMenu,()=>{gameState=0,update.transitioning=!1}])}}function draw(){for(object of(ctx.clearRect(0,0,w,h),ctx.translate(-panX,-panY),currentLevel.draw(),particles.draw(),currentLevel.objects))object.draw(object.position.x,object.position.y);player.draw(),ctx.translate(panX,panY),drawUI()}function shuffle(array){let currentIndex=array.length,randomIndex,currentElement;for(;currentIndex;)randomIndex=Math.floor(Math.random()*currentIndex--),currentElement=array[currentIndex],array[currentIndex]=array[randomIndex],array[randomIndex]=currentElement;return array}function clamp(value,min,max){return Math.min(max,Math.max(value,min))}function lerp(start,end,weight){return(1-clamp(weight,0,1))*start+clamp(weight,0,1)*end}function smoothStart(weight,magnitude){let sWeight=weight;for(let i=0;i<magnitude;i++)sWeight*=weight;return sWeight}function smoothStop(weight,magnitude){let sWeight=1-weight;for(let i=0;i<magnitude;i++)sWeight*=1-weight;return 1-sWeight}this.onload=()=>{canvas=document.getElementById("canvas"),ctx=canvas.getContext("2d"),particles=new ParticleSystem(2304),canvas.addEventListener("touchstart",enableTouch),window.oncontextmenu=e=>{e.preventDefault(),e.stopPropagation()},window.addEventListener("resize",resizeCanvas),window.addEventListener("orientationchange",resizeCanvas),resizeCanvas(),setInterval(update,1e3/60)};class ParticleSystem{_stride=6;lastParticle=0;constructor(size){this.data=new Array(size*this._stride),this.data.fill(0)}reset(){this.data.fill(0)}update(){for(let p=0;p<this.data.length;p+=this._stride)if(this.data[p]>GRND){if(this.data[p+3]){let tx=this.data[p+1]+this.data[p+3];currentLevel.getType(0,tileAtCoords(tx,this.data[p+2]))>GRND?this.data[p+3]*=-1:this.data[p+1]=tx,Math.abs(this.data[p+3])<.01?this.data[p+3]=0:this.data[p+3]*=.96}if(this.data[p+4]){let ty=this.data[p+2]+this.data[p+4];currentLevel.getType(0,tileAtCoords(this.data[p+1],ty))>GRND?this.data[p+3]*=-1:this.data[p+2]=ty,Math.abs(this.data[p+4])<.01?this.data[p+4]=0:this.data[p+4]*=.96}}}draw(){for(let p=0;p<this.data.length;p+=this._stride)if(this.data[p]>GRND&&pointInView(this.data[p+1],this.data[p+2])){let tile=tileAtCoords(Math.round(this.data[p+1]),Math.round(this.data[p+2])),tileType=currentLevel.getType(1,tile),color=tileType>GRND?averageHexColors([substColors[tileType],substColors[this.data[p]]]):substColors[this.data[p]];colorRect(this.data[p+1],this.data[p+2],this.data[p+5],this.data[p+5],color,!0)}}spawn(particle,amount){if(!Array.isArray(particle)||particle.length!=this._stride)throw new Error("invalid particle definition");{let particlesSpawned=0;for(let p=0;p<this.data.length;p+=this._stride){if(this.data[p]==GRND){for(let i=0;i<particle.length;i++)this.data[p+i]=particle[i];particlesSpawned++}if(particlesSpawned>=amount)break}if(particlesSpawned<amount)for(;particlesSpawned<amount;particlesSpawned++){for(let i=0;i<particle.length;i++)this.data[this.lastParticle+i]=particle[i];this.lastParticle+=this._stride,this.lastParticle>=this.data.length&&(this.lastParticle=0)}}}}class Vector2{constructor(x,y){this.x=x,this.y=y}add(vector){return new Vector2(this.x+vector.x,this.y+vector.y)}subtract(vector){return new Vector2(this.x-vector.x,this.y-vector.y)}multiply(scalar){return 0===scalar?new Vector2(0,0):new Vector2(this.x*scalar,this.y*scalar)}divide(scalar){return 0===scalar?new Vector2(0,0):new Vector2(this.x/scalar,this.y/scalar)}rotate(angle){let x=this.x*Math.cos(angle)-this.y*Math.sin(angle),y=this.x*Math.sin(angle)+this.y*Math.cos(angle);return new Vector2(x,y)}dotProduct(vector,normalized){let v1=normalized?this:this.normalize(),v2=normalized?vector:vector.normalize();return v1.x*v2.x+v1.y*v2.y}normalize(){let magnitude=Math.hypot(this.x,this.y);return this.divide(magnitude)}get length(){return Math.hypot(this.x,this.y)}set length(scalar){if(scalar<=0)this.x=this.y=0;else{let nv=this.normalize().multiply(scalar);this.x=nv.x,this.y=nv.y}}get angle(){return Math.atan2(this.y,this.x)}}function physicsUpdate(){updateElements();let cv=control();cv&&cv.length&&(player.rotation=player.rotation.add(cv).normalize(),player.velocity=player.velocity.add(cv.multiply(player.acceleration)),player.sway++),moveObject(player),player.updateHeld(),player.interactables.length=0;for(let i=0;i<currentLevel.objects.length;i++){if(object=currentLevel.objects[i],0==object.velocity.x&&0==object.velocity.y||(moveObject(object),Math.abs(object.velocity.x)<.01&&(object.velocity.x=0),Math.abs(object.velocity.y)<.01&&(object.velocity.y=0),0==Math.abs(object.velocity.x)&&0==Math.abs(object.velocity.y)&&(object.active=!0,object.onCollision(null))),pointInView(object.x,object.y)){let collision=checkCollision(player,object.interactCollider);collision.hit&&object.onCollision(player,collision)}for(let j=i+1;j<currentLevel.objects.length;j++){let otherObject=currentLevel.objects[j],collision=checkCollision(object,otherObject);if(collision.hit){"dynamic"==object.physics&&"dynamic"==otherObject.physics&&(collision.overlap.x/=2,collision.overlap.y/=2);let delta=new Vector2(object.x-otherObject.x,object.y-otherObject.y);"dynamic"==object.physics&&correctCollision(object,delta,collision.overlap),"dynamic"==otherObject.physics&&(delta.x*=-1,delta.y*=-1,correctCollision(otherObject,delta,collision.overlap))}}}particles.update()}function moveObject(object){object.velocity.length>object.size?continuousTileCollision(object):(object.position=object.position.add(object.velocity),objectTileCollision(object)),object.velocity=object.velocity.multiply(.96)}function updateElements(){let tileDestroyed=!1;for(let e=currentLevel.length-1;e>=0;e--)for(let layer=0;layer<2;layer++){let type=currentLevel.getType(layer,e);if(type<=GRND)continue;if(1==substanceTypes[type].state&&currentLevel.getLife(layer,e)<=0){let tx=e%currentLevel.width,ty=(e-tx)/currentLevel.width*TILE_SIZE;tx*=TILE_SIZE,particles.spawn([type,tx,ty,1-2*Math.random(),1-2*Math.random(),PARTICLE_SIZE],1),particles.spawn([type,tx,ty+PARTICLE_SIZE,1-2*Math.random(),1-2*Math.random(),PARTICLE_SIZE],1),particles.spawn([type,tx+PARTICLE_SIZE,ty+PARTICLE_SIZE,1-2*Math.random(),1-2*Math.random(),PARTICLE_SIZE],1),particles.spawn([type,tx+PARTICLE_SIZE,ty,1-2*Math.random(),1-2*Math.random(),PARTICLE_SIZE],1),currentLevel.resetTile(layer,e),tileDestroyed=!0}1==layer&&elementEffectOnTile(e,type);let checkTiles=shuffle(tilesNearIndex(e));for(let checkTile of checkTiles){if(checkTile==e)continue;let ctType;currentLevel.getType(layer,checkTile)>-1&&elementSpread(layer,e,checkTile)}}tileDestroyed&&zzfx(...SOUND_EFFECTS.destroytile)}function elementEffectOnTile(tileIndex,elementType){let state=substanceTypes[elementType].state,tileType=currentLevel.getType(0,tileIndex),decay=Math.random()/2,lifeTime;if(state>=3&&currentLevel.addLife(1,tileIndex,-decay),4==state&&(substanceTypes[tileType].effects.has(elementType)?tileType>GRND&&(currentLevel.addLife(0,tileIndex,-decay),currentLevel.addLife(1,tileIndex,decay)):elementInteraction(elementType,tileIndex)||currentLevel.resetTile(1,tileIndex),currentLevel.getLife(0,tileIndex)<=0&&(currentLevel.resetTile(0,tileIndex),currentLevel.resetTile(1,tileIndex))),currentLevel.getLife(1,tileIndex)<=0){let deathEffect=substanceTypes[elementType].ondeath;deathEffect>=GRND?currentLevel.spawnTile(tileIndex,deathEffect):currentLevel.setType(1,tileIndex,GRND)}}function elementSpread(layer,tileFrom,tileTo){let fromType=currentLevel.getType(layer,tileFrom),state;if(substanceTypes[fromType]&&1==(state=substanceTypes[fromType].state))return;let airType=currentLevel.getType(layer,tileTo),groundType=currentLevel.getType(0,tileTo),toType=state>2?airType:groundType,hasType;if(fromType>GRND)if(substanceTypes[state>2?groundType:airType].effects.has(fromType)&&(toType<=GRND||toType==fromType||substanceTypes[toType].effects.has(fromType))){let spreadQuant=state>2?4:1;if(state<4&&currentLevel.getQuantity(layer,tileFrom)>spreadQuant){let toQuant=airType==fromType?currentLevel.getQuantity(layer,tileTo):0;toQuant?currentLevel.addLife(layer,tileTo,Math.random()):currentLevel.spawnTile(tileTo,fromType),currentLevel.setQuantity(layer,tileTo,toQuant+spreadQuant),3===state&&(spreadQuant*=1.2),currentLevel.addQuantity(layer,tileFrom,-spreadQuant)}else 4==state&&Math.random()>.96&&currentLevel.spawnTile(tileTo,fromType)}else elementInteraction(fromType,tileTo)}function elementInteraction(fromType,tileTo){let groundType=currentLevel.getType(0,tileTo),airType=currentLevel.getType(1,tileTo),result,interactLayer;return effectMatrix[fromType]?(result=effectMatrix[fromType][groundType])<=GRND?(result=effectMatrix[fromType][airType],interactLayer=1):interactLayer=0:(console.log("invalid substance type for interaction"),result=null),!!(result&&result>GRND)&&(currentLevel.resetTile(interactLayer,tileTo),currentLevel.spawnTile(tileTo,result),!0)}let player={_hp:100,_sway:0,useTime:20,swingTimer:0,loot:0,color:"#4060C0",size:TILE_SIZE,held:-1,interactables:[],items:new Array(4),position:new Vector2(2*TILE_SIZE,2*TILE_SIZE),rotation:new Vector2(0,1),velocity:new Vector2(0,0),swingRotation:new Vector2(0,1),acceleration:TILE_SIZE/60,type:"circle",physics:"dynamic",reset(){this.isDead=!1,this._hp=100,this.loot=0,this.items.fill(null),this.items[0]=new Hammer(0,0),this.items[1]=new Grenade(0,0),this.held=-1,this.velocity.length=0,this.rotation.x=0,this.rotation.y=1},pickup(item){for(let i=0;i<this.items.length;i++)if(!this.items[i]){item.swingTimer=0,this.items[i]=item,this.held=i,zzfx(...SOUND_EFFECTS.pickup);let index=currentLevel.objects.indexOf(item);index>=0&&currentLevel.objects.splice(index,1);break}},drop(index){if(this.items[index]){let item=this.items[index];this.items[index]=null,item.x=this.x,item.y=this.y,currentLevel.objects.push(item),zzfx(...SOUND_EFFECTS.drop)}},interact(){this.interactables[0]&&this.interactables[0].onInteract()},use(){let heldItem=this.items[this.held];!this.swingTimer&&heldItem&&(null==heldItem.durability||heldItem.durability>0)&&(this.swingTimer=1,zzfx(...SOUND_EFFECTS.use))},tileEffect(type){10==type&&(this.hp-=.125)},updateHeld(){let item=this.items[this.held];this.swingTimer>0&&(this.swingTimer++,this.swingTimer==Math.floor(this.useTime/2)?item.onUse():this.swingTimer==this.useTime+8&&(this.swingTimer=0,this.swingRotation.x=0,this.swingRotation.y=0))},draw(){let color=this.isDead?"#203060":this.color,tileColors=nearTileColors(1,this.x,this.y),emptyTiles=9-tileColors.length;tileColors.length&&(color=averageHexColors(tileColors.concat(new Array(tileColors.length+emptyTiles).fill(color)))),setShadow("black",2);let armOffset=this.size-this.size/4,armAngle=this.rotation.rotate(Math.PI/2);for(item of(armAngle=armAngle.multiply(this.size),armAngle=armAngle.add(this.rotation.multiply(Math.sin(this.sway/10)*armOffset)),colorCircle(this.x-armAngle.x,this.y-armAngle.y,this.size/2,color,!0),this.swingTimer&&(armAngle=this.swingRotation.multiply(this.size)),colorCircle(this.x+armAngle.x,this.y+armAngle.y,this.size/2,color,!0),this.drawHeld(),colorCircle(this.x,this.y,this.size,color,!0),resetShadow(),ctx.strokeStyle="#ffffff",ctx.beginPath(),ctx.moveTo(this.x,this.y),ctx.lineTo(this.x+this.rotation.x*this.size,this.y+this.rotation.y*this.size),ctx.stroke(),this.interactables))item.drawLabel(item.x,item.y)},drawHeld(){let item=this.items[this.held];if(item&&this.swingTimer){let offset=lerp(Math.PI,0,smoothStop(clamp(this.swingTimer,0,this.useTime)/this.useTime,3));this.swingRotation=this.rotation.rotate(offset),ctx.translate(this.x,this.y),ctx.rotate(this.swingRotation.angle+Math.PI/2),item.draw(0,-item.size/2-player.size/2),ctx.rotate(-(this.swingRotation.angle+Math.PI/2)),ctx.translate(-this.x,-this.y)}},die(){this.isDead=!0;let dIndex=tileAtCoords(this.position.x,this.position.y);currentLevel.spawnTile(dIndex,7),gameState=2},get radius(){return this.size},get x(){return this.position.x},get y(){return this.position.y},get hp(){return this._hp},set hp(val){this._hp=clamp(val,0,100),0!=this._hp||this.isDead||this.die()},get sway(){return this._sway},set sway(value){this._sway=value,this._sway>120&&(this._sway=0)}};const HP_COLOR="#ff6060";function drawMainMenu(){let tHeight=canvas.height/4*(canvas.width/canvas.height/2);tHeight=clamp(tHeight,0,canvas.width/1.5),colorRect(0,0,w,h,substColors[GRND]),colorText("Loot Not Found",canvas.width/2,canvas.height/2,substColors[5],tHeight+"px Arial","center","middle"),drawPressInteract(tHeight,"start")}function drawWinScreen(){let tHeight=canvas.height/6*(canvas.width/canvas.height/2);tHeight=clamp(tHeight,0,canvas.width/1.5),colorRect(0,0,w,h,substColors[GRND]),colorText("Escape Successful",canvas.width/2,canvas.height/2,substColors[5],tHeight+"px Arial","center","middle"),drawPressInteract(tHeight,"play again")}function drawGameOver(){let tHeight=canvas.height/6*(canvas.width/canvas.height/2);setShadow("black",6),tHeight=clamp(tHeight,0,canvas.width/1.5),colorText("You Died",canvas.width/2,canvas.height/2,substColors[10],tHeight+"px Arial","center","middle"),drawPressInteract(tHeight,"restart"),resetShadow()}function drawPressInteract(fontSize,action){ctx.font=fontSize/2+"px Arial";let yOffset=1.25*fontSize/2,x=canvas.width/2,y=canvas.height/2+yOffset,xOffset=-ctx.measureText("Press [Interact] "+action).width/3;colorText("Press ",x+xOffset,y,substColors[3]),xOffset+=ctx.measureText("Press ").width/2+ctx.measureText("[Interact] ").width/2,colorText("[Interact] ",x+xOffset,y,substColors[10]),xOffset+=ctx.measureText("[Interact] ").width/2+ctx.measureText("to "+action).width/2,colorText("to "+action,x+xOffset,y,substColors[3])}function drawUI(){controls.items&&drawItemMenu(),drawHUD()}function drawItemMenu(){let itemBoxSize=2*TILE_SIZE,bx=player.x-panX-itemBoxSize/2,by=player.y-panY-itemBoxSize/2,index=0;player.held>=0&&player.items[player.held]&&colorText("Press [Interact] to drop selected item",player.x-panX,by-itemBoxSize-16,"white","16px Arial","center");for(let y=-1;y<2;y++)for(let x=-1;x<2;x++)(1==Math.abs(y)&&0==Math.abs(x)||1==Math.abs(x)&&0==Math.abs(y))&&(colorRect(bx+itemBoxSize*x,by+itemBoxSize*y,itemBoxSize,itemBoxSize,player.held==index?"dimgrey":"black"),player.items[index]&&player.items[index].draw(bx+itemBoxSize*x+itemBoxSize/2,by+itemBoxSize*y+itemBoxSize/2),index++)}function drawHUD(){let fontSize=w/50,x=Math.floor(canvas.width/2),y=canvas.height-Math.floor(2*fontSize);setShadow("black",6),colorRect(x,y+fontSize/2,25*fontSize,3*fontSize,averageHexColors([substColors[1],substColors[GRND]]),!0),resetShadow(),drawHP(x,y,fontSize),drawLoot(x-5*fontSize,y,fontSize),drawHeldItem(x+5*fontSize,y,fontSize);let exit=currentLevel.exit;if(!exit.locked){ctx.font=exit.size/2+"px Arial";let width=ctx.measureText("ESCAPE THE AREA").width/2,x=exit.x-panX,y=exit.y-panY;padding=exit.size/2,x=clamp(x,width+padding/2,w-width-padding/2),y=clamp(y,padding,h-padding),setShadow(substColors[10],3,1,1),colorText("ESCAPE THE AREA",x,y,substColors[5],null,"center","middle"),resetShadow()}}function drawHP(x,y,fontSize){let barWidth=10*fontSize,left=x,top=y+fontSize/2,hpRatio=player.hp/100;colorText("HP",x,y,"white",fontSize+"px Arial","center","middle"),colorRect(left-barWidth/2-2,top-2,barWidth+4,fontSize/2+4,"black"),colorRect(left-hpRatio*barWidth/2,top,hpRatio*barWidth,fontSize/2,HP_COLOR)}function drawLoot(x,y,fontSize){let lootWidth=ctx.measureText("LOOT").width,numWidth,top=y,left=x-(lootWidth+ctx.measureText(100).width+fontSize);colorText("LOOT",left,top,"white",fontSize+"px Arial","left","middle"),colorText(player.loot,left+lootWidth+fontSize/2,top,"#ffca00")}function drawHeldItem(x,y,fontSize){let heldItem=player.items[player.held],item=(player.items[player.held]?player.items[player.held].constructor.name:"No Item").toUpperCase();ctx.font=fontSize+"px Arial";let boxSize=ctx.measureText("FIREBOMB").width+fontSize,top=y,left=x+boxSize/2+fontSize/2;if(colorText(item,left,top,"white",null,"center","middle"),heldItem&&null!=heldItem.durability)if(heldItem.durability>0){let barSize=boxSize/1.5,durSize=barSize*(player.items[player.held].durability/100);colorRect(left-barSize/2-2,top+fontSize/2-2,barSize+4,fontSize/2+4,"black"),colorRect(left-durSize/2,top+fontSize/2,durSize,fontSize/2,HP_COLOR)}else colorText("BROKEN",left,top+fontSize,HP_COLOR)}let zzfx,zzfxV,zzfxX,zzfxR;zzfxV=.3,zzfx=(q=1,k=.05,c=220,e=0,t=0,u=.1,r=0,F=1,v=0,z=0,w=0,A=0,l=0,B=0,x=0,G=0,d=0,y=1,m=0,C=0)=>{let b=2*Math.PI,H=v*=500*b/zzfxR**2,I=(0<x?1:-1)*b/4,D=c*=(1+2*k*Math.random()-k)*b/zzfxR,Z=[],g=0,E=0,a=0,n=1,J=0,K=0,f=0,p,h;for(z*=500*b/zzfxR**3,x*=b/zzfxR,w*=b/zzfxR,A*=zzfxR,l=zzfxR*l|0,h=(e=99+zzfxR*e)+(m*=zzfxR)+(t*=zzfxR)+(u*=zzfxR)+(d*=zzfxR)|0;a<h;Z[a++]=f)++K%(100*G|0)||(f=r?1<r?2<r?3<r?Math.sin((g%b)**3):Math.max(Math.min(Math.tan(g),1),-1):1-(2*g/b%2+2)%2:1-4*Math.abs(Math.round(g/b)-g/b):Math.sin(g),f=(l?1-C+C*Math.sin(2*Math.PI*a/l):1)*(0<f?1:-1)*Math.abs(f)**F*q*zzfxV*(a<e?a/e:a<e+m?1-(a-e)/m*(1-y):a<e+m+t?y:a<h-d?(h-a-d)/u*y:0),f=d?f/2+(d>a?0:(a<h-d?1:(h-a)/d)*Z[a-d|0]/2):f),p=(c+=v+=z)*Math.sin(E*x-I),g+=p-p*B*(1-1e9*(Math.sin(a)+1)%2),E+=p-p*B*(1-1e9*(Math.sin(a)**2+1)%2),n&&++n>A&&(c+=w,D+=w,n=0),!l||++J%l||(c=D,v=H,n=n||1);return(q=zzfxX.createBuffer(1,h,zzfxR)).getChannelData(0).set(Z),(c=zzfxX.createBufferSource()).buffer=q,c.connect(zzfxX.destination),c.start(),c},zzfxX=new(window.AudioContext||webkitAudioContext),zzfxR=44100;
	</script>
</head>

<body>
	<div class='directionbutton up hidden'
		ontouchstart=setControl(87,1)
		ontouchend=setControl(87,0)
		ontouchcancel=setControl(87,0)
		ontouchleave=setControl(87,0)>
	</div>
	<div class='directionbutton right hidden'
		ontouchstart=setControl(68,1)
		ontouchend=setControl(68,0)
		ontouchcancel=setControl(68,0)
		ontouchleave=setControl(68,0)>
	</div>
	<div class='directionbutton down hidden'
		ontouchstart=setControl(83,1)
		ontouchend=setControl(83,0)
		ontouchcancel=setControl(83,0)
		ontouchleave=setControl(83,0)>
	</div>
	<div class='directionbutton left hidden'
		ontouchstart=setControl(65,1)
		ontouchend=setControl(65,0)
		ontouchcancel=setControl(65,0)
		ontouchleave=setControl(65,0)>
	</div>

	<div class='gamebutton itemsbutton hidden'
		ontouchstart=setControl(69,1)
		ontouchend=setControl(69,0)
		ontouchcancel=setControl(69,0)
		ontouchleave=setControl(69,0)>
		Items
	</div>

	<div class='gamebutton interactbutton hidden'
		ontouchstart=setControl(32,1)
		ontouchend=setControl(32,0)
		ontouchcancel=setControl(32,0)
		ontouchleave=setControl(32,0)>
		Interact
	</div>
	
	<canvas id="canvas"></canvas>
</body>

</html>
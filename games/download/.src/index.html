<!DOCTYPE html><html><head> <meta charset="utf-8"/> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Download!!!</title> <meta name="viewport" content="width=device-width, initial-scale=1"></head><style>html, body{margin: 0; padding: 0; background: #000; color: #fff; font-family: sans-serif;}canvas{cursor: none; padding-left: 0; padding-right: 0; margin-left: auto; margin-right: auto; display: block;}canvas:focus{outline: none;}.note, .lose, .win{position: absolute; float: left; left: 50%; top: 50%; text-align: center; transform: translate(-50%, -50%); padding: 20px; border-radius: 4px; background: #fff; color: #000;}.lose{background: red; color: #fff; display: none;}.win{background: green; color: #fff; display: none;}</style><body> <h2 id="note" class="note"> Safely download the data before the it is disconnected! <br><br>Use arrow keys to move the data </h2> <h2 id="lose" class="lose">Disconnected :(</h2> <h2 id="win" class="win">Data downloaded 0%</h2> <canvas id="canvas"></canvas></body><script src="dist/gim.js"></script><script>var _extends=Object.assign||function(a){for(var c,b=1;b<arguments.length;b++)for(var d in c=arguments[b],c)Object.prototype.hasOwnProperty.call(c,d)&&(a[d]=c[d]);return a};function win(a=0){let b=document.getElementById('win');b.style.display='initial',b.innerHTML='Data downloaded '+a+'%',document.getElementById('canvas').style.display='none'}function lose(){document.getElementById('lose').style.display='initial',document.getElementById('canvas').style.display='none'}function start(){document.getElementById('note').style.display='none',document.getElementById('canvas').focus(),game.start()}let game=new gim.Game('canvas',500,window.innerHeight);const Packet={x:game.canvas.width/2-25,y:50,width:40,height:40,speed:4,onKeyDown(a){'right'==a&&(packet.x+=this.speed),'left'==a&&(packet.x-=this.speed),'up'==a&&(packet.y-=this.speed),'down'==a&&(packet.y+=this.speed)},update(){if(!(0>=this.width))return(this.x>=tunnel.x+tunnel.width-this.width&&(this.x=tunnel.x+tunnel.width-this.width-1,this.shrink()),this.x<=tunnel.x&&(this.x=tunnel.x+1,this.shrink()),0>=this.width)?(game.stop(),console.log('Disconnected :('),void lose()):void 0},shrink(){this.width-=0.05*Packet.width,this.height-=0.05*Packet.height},grow(){this.width+=0.05*Packet.width,this.height+=0.05*Packet.height},render(a){a.fillStyle='#006CAA',a.fillRect(this.x,this.y,this.width,this.height)}},Tunnel={x:0,y:0,width:game.canvas.width,height:game.canvas.height,shrink(){this.width-=0.4,this.x+=0.2},update(){return 0>=this.width?void lose():void this.shrink()},render(a){a.fillStyle='#fff',a.fillRect(this.x,this.y,this.width,this.height)}},Obstacle={x:0,y:game.canvas.height,width:5,height:5,speed:8,isCollide(a){return this.x<a.x+a.width&&this.x+this.width>a.x&&this.y<a.y+a.height&&this.y+this.height>a.y},randomX(){this.x=Math.floor(Math.random()*(game.canvas.height-this.width))},randomSpeed(){this.speed=Math.ceil(Math.random()*7+3)},reset(){this.y=game.canvas.height,this.randomX(),this.randomSpeed()},update(a,b){this.y<-this.height&&this.reset(),this.isCollide(packet)&&(this.reset(),packet.shrink());this.y==b.canvas.height&&tunnel.width<=Packet.width+15||(this.y-=this.speed)},render(a){a.fillStyle='#000',a.fillRect(this.x,this.y,this.width,this.height)}},Finish={x:0,y:game.canvas.height,width:Packet.width+10,height:20,isCollide(a){return this.x<a.x+a.width&&this.x+this.width>a.x&&this.y<a.y+a.height&&this.y+this.height>a.y},shrink(){0>=this.width||(this.width-=0.4,this.x+=0.2)},update(){if(this.x=game.canvas.width/2-this.width/2,this.isCollide(packet)){game.stop();let a=100*(packet.width/Packet.width);return console.log('Data downloaded '+a+'%'),void win(a)}tunnel.width<=Packet.width+15&&(this.y-=2,this.shrink()),this.y<=game.canvas.height-10},render(a){a.fillStyle='green',a.fillRect(this.x,this.y,this.width,this.height)}};let finish=_extends({},Finish),tunnel=_extends({},Tunnel),packet=_extends({},Packet),obstacles=[];for(let b,a=0;20>a;a++)b=_extends({},Obstacle),b.randomX(),b.randomSpeed(),obstacles.push(b);game.keyboard.on('down',(a,b)=>{packet.onKeyDown(a,b)}),game.on('update',(a,b)=>{tunnel.update(a,b),packet.update(a,b),finish.update(a,b),obstacles.forEach(c=>c.update(a,b))}),game.on('render',a=>{tunnel.render(a.ctx),packet.render(a.ctx),finish.render(a.ctx),obstacles.forEach(b=>b.render(a.ctx))}),setTimeout(start,4e3);</script></html>
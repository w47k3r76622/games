import{gl}from"./init.js";import{ElementBuffer,FloatVec3,GLArrayBuffer,Program,Shader}from"./webgl.js";const vs=new Shader(gl.VERTEX_SHADER,[{type:"vec4",name:"aPosition"},{type:"vec3",name:"aColor"}],[{type:"mat4",name:"projection"}],"\nvarying vec3 color;\n\nvoid main() {\n\tgl_Position = projection * aPosition;\n\tcolor = aColor;\n}\n"),fs=new Shader(gl.FRAGMENT_SHADER,[],[],"\nvarying vec3 color;\n\nvoid main() {\n\tgl_FragColor = vec4(color, 1.0);\n}\n"),width=40,height=25,vertsData=[],angleStep=.025*Math.PI*2;let heightStep,angle=0;{const e=new FloatVec3(Math.sin(angle),0,Math.cos(angle)),o=new FloatVec3(Math.sin(angle+angleStep),0,Math.cos(angle+angleStep)).mulScalar(-1);heightStep=3*e.add(o).length2()}for(let e=0;e<40;e++){for(let e=0;e<25;e++)vertsData.push(Math.sin(angle+e%2*angleStep/2),-heightStep*e,Math.cos(angle+e%2*angleStep/2));angle+=angleStep}const indicesData=[];for(let e=0;e<40;e+=1)for(let o=1;o<25;o+=2)indicesData.push(25*e+o-1,(e+1)%40*25+o-1,25*e+o,(e+1)%40*25+o-1,(e+1)%40*25+o,25*e+o,25*e+o,(e+1)%40*25+o+1,25*e+o+1,(e+1)%40*25+o+1,25*e+o,(e+1)%40*25+o);const rand=()=>window.crypto.getRandomValues(new Uint32Array(1))[0]/4228250625,getColor=e=>{if(e<.66){e/=.66,e*=e;const o=[66,46,83];return[16,16,29].map((t,a)=>(t+e*(o[a]-t))/255)}{e=(e-.66)/(1-.66),e*=e;const o=[144,46,84];return[66,46,83].map((t,a)=>(t+e*(o[a]-t))/255)}},colorData=[];for(let e=0;e<40;e++){const o=6*Math.sin(e/40*2*Math.PI+Math.PI/6);for(let e=0;e<25;e++)colorData.push(...getColor(1-((e+o)/25+.03*rand())-.1))}export class Skybox{}Skybox.program=new Program([vs,fs]),Skybox.indices=new ElementBuffer(new Uint16Array(indicesData)),Skybox.positions=new GLArrayBuffer(new Float32Array(vertsData),3,gl.FLOAT),Skybox.colors=new GLArrayBuffer(new Float32Array(colorData),3,gl.FLOAT),Skybox.getColor=getColor,Skybox.program.attributes.get("aPosition").value=Skybox.positions,Skybox.program.attributes.get("aColor").value=Skybox.colors;
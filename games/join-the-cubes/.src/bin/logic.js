import{immovableColor,maps}from"./maps.js";import{GrabState}from"./state.js";import{FloatVec3,Quaternion}from"./webgl.js";const rand=()=>window.crypto.getRandomValues(new Uint32Array(1))[0]/4228250625,cameraMoveSpeed=1,cameraRotSpeed=Math.PI/6,clamp=(e,a,t)=>Math.max(e,Math.min(a,t)),startGrab=e=>{const{x:a,z:t}=e.armPos;if(e.groundLevel=e.firstNonempty(a,t),-1==e.groundLevel)return;const r=e.cubesOnMap[a][e.groundLevel][t];if(!e.generators.has(r)&&r.color!=immovableColor){e.neighbourLevel=e.groundLevel;for(let r=-1;r<=1;r++)for(let o=-1;o<=1;o++){const n=a+r,s=t+o;e.neighbourLevel=Math.max(e.neighbourLevel,e.firstNonempty(n,s))}e.neighbourLevel+=1,e.grabRotAxis.x=Math.sin(rand()*Math.PI*2),e.grabRotAxis.y=Math.sin(rand()*Math.PI*2),e.grabRotAxis.z=Math.sin(rand()*Math.PI*2),e.grabRotAxis.normalize(),e.cubesOnMap[a][e.groundLevel][t]=null,e.grabbedCube=r,e.grabState=GrabState.Grabbing,updateConnectivity(e)}},startDrop=e=>{const{x:a,z:t}=e.armPos,r=e.firstNonempty(a,t);if(r==e.mapSize.y-1)return;e.groundLevel=r+1,e.neighbourLevel=e.groundLevel;for(let r=-1;r<=1;r++)for(let o=-1;o<=1;o++){const n=a+r,s=t+o;e.neighbourLevel=Math.max(e.neighbourLevel,e.firstNonempty(n,s))}e.neighbourLevel+=1;const o=e.grabbedCube.rotation,n=(new Quaternion).copy(o),s=e=>{const a=(new FloatVec3).copy(e);a.applyQuat(n);let t=Math.abs(a.x)>Math.abs(a.y)?"x":"y";t=Math.abs(a[t])>Math.abs(a.z)?t:"z";const r=new FloatVec3;r[t]=Math.sign(a[t]);const o=Math.acos(a.dot(r)),s=a.cross(r).normalize();return(new Quaternion).fromAxisAngle(s,o)};e.droppingRot1=(new Quaternion).copy(o);const c=s(new FloatVec3(1,0,0));n.preMul(c);const b=s(new FloatVec3(0,1,0));e.droppingRot2=(new Quaternion).copy(o).preMul(c.preMul(b)),e.grabState=GrabState.Dropping};export const stopDrop=e=>{e.cubesOnMap[e.armPos.x][e.groundLevel][e.armPos.z]=e.grabbedCube,e.grabbedCube=null,e.grabState=GrabState.Drop,updateConnectivity(e)};const flood=(e,a)=>{const{cubesOnMap:t}=a,r=t[e.x][e.y][e.z];if(!r)throw null;const o=[r],n=new Set(o),s=null==r?void 0:r.color,c=(e,a,r)=>{const s=t[e]&&t[e][a]&&t[e][a][r];s&&!n.has(s)&&o.push(s)};for(;o.length>0;){const e=o.pop();if(e.color===s){n.add(e);const{x:a,y:t,z:r}=e.position;c(a+1,t,r),c(a-1,t,r),c(a,t+1,r),c(a,t-1,r),c(a,t,r+1),c(a,t,r-1)}}return n},exitMap=()=>{const e=document.getElementById("overlay").classList;e.contains("game")&&(e.remove("game"),e.add("level"),document.exitPointerLock())};export const updateConnectivity=e=>{const{connectedCubes:a,fullyConnectedCubes:t,generators:r,generatorCount:o}=e;a.clear(),t.clear();const n=new Set;r.forEach(({position:s,color:c})=>{let b=0;const i=flood(s,e);r.forEach(e=>{i.has(e)&&(b+=1)}),b==o.get(c)?(n.add(c),i.forEach(e=>{t.add(e)})):i.forEach(e=>{r.has(e)||a.add(e)})}),n.size===o.size&&(document.getElementById("level-"+maps.currentId).classList.add("done"),exitMap())};export const handleActions=(e,a)=>{const t=[()=>e.targetArmPos.z=clamp(0,e.targetArmPos.z-1,e.mapSize.z-1),()=>e.targetArmPos.x=clamp(0,e.targetArmPos.x-1,e.mapSize.x-1),()=>e.targetArmPos.z=clamp(0,e.targetArmPos.z+1,e.mapSize.z-1),()=>e.targetArmPos.x=clamp(0,e.targetArmPos.x+1,e.mapSize.x-1)],r=e=>(e%4+4)%4,o=Math.round(e.camRot/cameraRotSpeed/3);for(const n of a){switch(n){case"Escape":case"Backspace":exitMap();break;case"KeyW":e.targetCamPos.y-=1;break;case"KeyS":e.targetCamPos.y+=1;break;case"KeyA":e.targetCamRot=e.targetCamRot+cameraRotSpeed;break;case"KeyD":e.targetCamRot=e.targetCamRot-cameraRotSpeed;break;case"Space":switch(e.armPos.x=e.targetArmPos.x,e.armPos.z=e.targetArmPos.z,e.grabState){case GrabState.Drop:startGrab(e);break;case GrabState.Grabbing:e.grabState=GrabState.Dropping;break;case GrabState.Grab:startDrop(e);break;case GrabState.Dropping:e.grabState=GrabState.Grabbing}}let a=!1;switch(n){case"ArrowRight":case"KeyL":t[r(3-o)](),a=!0;break;case"ArrowLeft":case"KeyJ":t[r(1-o)](),a=!0;break;case"ArrowDown":case"KeyK":t[r(2-o)](),a=!0;break;case"ArrowUp":case"KeyI":t[r(0-o)](),a=!0}a&&e.grabbedCube&&(e.grabState==GrabState.Dropping&&(e.grabbedCube.position.y=e.groundLevel),e.grabState==GrabState.Grabbing&&(e.grabbedCube.position.y=e.grabHeight))}e.targetCamRot>Math.PI&&(e.targetCamRot-=2*Math.PI,e.camRot-=2*Math.PI),e.targetCamRot<-Math.PI&&(e.targetCamRot+=2*Math.PI,e.camRot+=2*Math.PI),e.targetCamPos.y=clamp(-e.mapSize.y,e.targetCamPos.y,0)};
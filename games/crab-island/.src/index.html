<head>
    <style>
        canvas {
            width: 100%;
            background: #fff
        }

        body {
            background: #000
        }
    </style>
    <script
        type="module">let t = () => { }; function i(t, i) { let e = i.parentNode; if (t.setAttribute("data-kontra", ""), e) { let s = e.querySelector("[data-kontra]:last-of-type") || i; e.insertBefore(t, s.nextSibling) } else document.body.appendChild(t) } function e(t, i) { let e = t.indexOf(i); if (-1 != e) return t.splice(e, 1), !0 } let s, h, r = {}; function n(t, i) { r[t] = r[t] || [], r[t].push(i) } function a(t, ...i) { (r[t] || []).map((t => t(...i))) } let o = { get: (i, e) => "_proxy" == e || t }; function l() { return h } function d(t, { contextless: i = !1 } = {}) { if (s = document.getElementById(t) || t || document.querySelector("canvas"), i && (s = s || new Proxy({}, o)), !s) throw Error("You must provide a canvas element for the game"); return h = s.getContext("2d") || new Proxy({}, o), h.imageSmoothingEnabled = !1, a("init"), { canvas: s, context: h } } function c(t, i) { return Math.atan2(i.y - t.y, i.x - t.x) + Math.PI / 2 } function p(t, i) { let e = Math.sin(i), s = Math.cos(i); return { x: t.x * s - t.y * e, y: t.x * e + t.y * s } } function u(t, i, e) { return Math.min(Math.max(t, e), i) } function y(t, i) { return [t, i] = [t, i].map((t => w(t))), t.x < i.x + i.width && t.x + t.width > i.x && t.y < i.y + i.height && t.y + t.height > i.y } function w(t) { let { x: i = 0, y: e = 0, width: s, height: h } = t.world || t; return t.mapwidth && (s = t.mapwidth, h = t.mapheight), t.anchor && (i -= s * t.anchor.x, e -= h * t.anchor.y), s < 0 && (i += s, s *= -1), h < 0 && (e += h, h *= -1), { x: i, y: e, width: s, height: h } } class x { constructor(t = 0, i = 0, e = {}) { this.x = t, this.y = i, e._c && (this.clamp(e._a, e._b, e._d, e._e), this.x = t, this.y = i) } add(t) { return new x(this.x + t.x, this.y + t.y, this) } subtract(t) { return new x(this.x - t.x, this.y - t.y, this) } scale(t) { return new x(this.x * t, this.y * t) } normalize(t = this.length()) { return new x(this.x / t, this.y / t) } dot(t) { return this.x * t.x + this.y * t.y } length() { return Math.hypot(this.x, this.y) } distance(t) { return Math.hypot(this.x - t.x, this.y - t.y) } angle(t) { return Math.acos(this.dot(t) / (this.length() * t.length())) } clamp(t, i, e, s) { this._c = !0, this._a = t, this._b = i, this._d = e, this._e = s } get x() { return this._x } get y() { return this._y } set x(t) { this._x = this._c ? u(this._a, this._d, t) : t } set y(t) { this._y = this._c ? u(this._b, this._e, t) : t } } function _() { return new x(...arguments) } class m extends class { constructor(t) { return this.init(t) } init(t = {}) { this.position = _(), this.velocity = _(), this.acceleration = _(), this.ttl = 1 / 0, Object.assign(this, t) } update(t) { this.advance(t) } advance(t) { let i = this.acceleration; t && (i = i.scale(t)), this.velocity = this.velocity.add(i); let e = this.velocity; t && (e = e.scale(t)), this.position = this.position.add(e), this._pc(), this.ttl-- } get dx() { return this.velocity.x } get dy() { return this.velocity.y } set dx(t) { this.velocity.x = t } set dy(t) { this.velocity.y = t } get ddx() { return this.acceleration.x } get ddy() { return this.acceleration.y } set ddx(t) { this.acceleration.x = t } set ddy(t) { this.acceleration.y = t } isAlive() { return this.ttl > 0 } _pc() { } }{ init({ width: t = 0, height: i = 0, context: e = l(), render: s = this.draw, update: h = this.advance, children: r = [], anchor: n = { x: 0, y: 0 }, opacity: a = 1, rotation: o = 0, scaleX: d = 1, scaleY: c = 1, ...p } = {}) { this._c = [], super.init({ width: t, height: i, context: e, anchor: n, opacity: a, rotation: o, scaleX: d, scaleY: c, ...p }), this._di = !0, this._uw(), this.addChild(r), this._rf = s, this._uf = h } update(t) { this._uf(t), this.children.map((i => i.update && i.update(t))) } render() { let t = this.context; t.save(), (this.x || this.y) && t.translate(this.x, this.y), this.rotation && t.rotate(this.rotation), 1 == this.scaleX && 1 == this.scaleY || t.scale(this.scaleX, this.scaleY); let i = -this.width * this.anchor.x, e = -this.height * this.anchor.y; (i || e) && t.translate(i, e), this.context.globalAlpha = this.opacity, this._rf(), (i || e) && t.translate(-i, -e), this.children.map((t => t.render && t.render())), t.restore() } draw() { } _pc() { this._uw(), this.children.map((t => t._pc())) } get x() { return this.position.x } get y() { return this.position.y } set x(t) { this.position.x = t, this._pc() } set y(t) { this.position.y = t, this._pc() } get width() { return this._w } set width(t) { this._w = t, this._pc() } get height() { return this._h } set height(t) { this._h = t, this._pc() } _uw() { if (!this._di) return; let { _wx: t = 0, _wy: i = 0, _wo: e = 1, _wr: s = 0, _wsx: h = 1, _wsy: r = 1 } = this.parent || {}; this._wx = this.x, this._wy = this.y, this._ww = this.width, this._wh = this.height, this._wo = e * this.opacity, this._wsx = h * this.scaleX, this._wsy = r * this.scaleY, this._wx = this._wx * h, this._wy = this._wy * r, this._ww = this.width * this._wsx, this._wh = this.height * this._wsy, this._wr = s + this.rotation; let { x: n, y: a } = p({ x: this._wx, y: this._wy }, s); this._wx = n, this._wy = a, this._wx += t, this._wy += i } get world() { return { x: this._wx, y: this._wy, width: this._ww, height: this._wh, opacity: this._wo, rotation: this._wr, scaleX: this._wsx, scaleY: this._wsy } } set children(t) { this.removeChild(this._c), this.addChild(t) } get children() { return this._c } addChild(...i) { i.flat().map((i => { this.children.push(i), i.parent = this, i._pc = i._pc || t, i._pc() })) } removeChild(...t) { t.flat().map((t => { e(this.children, t) && (t.parent = null, t._pc()) })) } get opacity() { return this._opa } set opacity(t) { this._opa = t, this._pc() } get rotation() { return this._rot } set rotation(t) { this._rot = t, this._pc() } setScale(t, i = t) { this.scaleX = t, this.scaleY = i } get scaleX() { return this._scx } set scaleX(t) { this._scx = t, this._pc() } get scaleY() { return this._scy } set scaleY(t) { this._scy = t, this._pc() } } function g() { return new m(...arguments) } class f extends m { init({ image: t, width: i = (t ? t.width : void 0), height: e = (t ? t.height : void 0), ...s } = {}) { super.init({ image: t, width: i, height: e, ...s }) } get animations() { return this._a } set animations(t) { let i, e; for (i in this._a = {}, t) this._a[i] = t[i].clone(), e = e || this._a[i]; this.currentAnimation = e, this.width = this.width || e.width, this.height = this.height || e.height } playAnimation(t) { this.currentAnimation = this.animations[t], this.currentAnimation.loop || this.currentAnimation.reset() } advance(t) { super.advance(t), this.currentAnimation && this.currentAnimation.update(t) } draw() { this.image && this.context.drawImage(this.image, 0, 0, this.image.width, this.image.height), this.currentAnimation && this.currentAnimation.render({ x: 0, y: 0, width: this.width, height: this.height, context: this.context }), this.color && (this.context.fillStyle = this.color, this.context.fillRect(0, 0, this.width, this.height)) } } function S() { return new f(...arguments) } let M = /(\d+)(\w+)/; class A extends m { init({ text: t = "", textAlign: i = "", lineHeight: e = 1, font: s = l().font, ...h } = {}) { t = "" + t, super.init({ text: t, textAlign: i, lineHeight: e, font: s, ...h }), this._p() } get width() { return this._w } set width(t) { this._d = !0, this._w = t, this._fw = t } get text() { return this._t } set text(t) { this._d = !0, this._t = "" + t } get font() { return this._f } set font(t) { this._d = !0, this._f = t, this._fs = function (t) { let i = t.match(M), e = +i[1]; return { size: e, unit: i[2], computed: e } }(t).computed } get lineHeight() { return this._lh } set lineHeight(t) { this._d = !0, this._lh = t } render() { this._d && this._p(), super.render() } _p() { this._s = [], this._d = !1; let t = this.context; if (t.font = this.font, !this._s.length && this._fw) { let i = this.text.split(" "), e = 0, s = 2; for (; s <= i.length; s++) { let h = i.slice(e, s).join(" "); t.measureText(h).width > this._fw && (this._s.push(i.slice(e, s - 1).join(" ")), e = s - 1) } this._s.push(i.slice(e, s).join(" ")) } if (!this._s.length && this.text.includes("\n")) { let i = 0; this.text.split("\n").map((e => { this._s.push(e), i = Math.max(i, t.measureText(e).width) })), this._w = this._fw || i } this._s.length || (this._s.push(this.text), this._w = this._fw || t.measureText(this.text).width), this.height = this._fs + (this._s.length - 1) * this._fs * this.lineHeight, this._uw() } draw() { let t = 0, i = this.textAlign, e = this.context; i = this.textAlign || ("rtl" == e.canvas.dir ? "right" : "left"), t = "right" == i ? this.width : "center" == i ? this.width / 2 | 0 : 0, this._s.map(((s, h) => { e.textBaseline = "top", e.textAlign = i, e.fillStyle = this.color, e.font = this.font, e.fillText(s, t, this._fs * this.lineHeight * h) })) } } function v() { return new A(...arguments) } new WeakMap; function b(t) { let i = t.canvas; t.clearRect(0, 0, i.width, i.height) } function z({ fps: i = 60, clearCanvas: e = !0, update: s = t, render: h, context: r = l(), blur: n = !1 } = {}) { if (!h) throw Error("You must provide a render() function"); let o, d, c, p, u, y = 0, w = 1e3 / i, x = 1 / i, _ = e ? b : t, m = !0; function g() { if (d = requestAnimationFrame(g), m && (c = performance.now(), p = c - o, o = c, !(p > 1e3))) { for (a("tick"), y += p; y >= w;)u.update(x), y -= w; _(r), u.render() } } return n || (window.addEventListener("focus", (() => { m = !0 })), window.addEventListener("blur", (() => { m = !1 }))), u = { update: s, render: h, isStopped: !0, start() { o = performance.now(), this.isStopped = !1, requestAnimationFrame(g) }, stop() { this.isStopped = !0, cancelAnimationFrame(d) }, _frame: g, set _last(t) { o = t } }, u } let E = {}, P = {}, k = {}, C = { Enter: "enter", Escape: "esc", Space: "space", ArrowLeft: "arrowleft", ArrowUp: "arrowup", ArrowRight: "arrowright", ArrowDown: "arrowdown" }; function D(i = t, e) { i._pd && e.preventDefault(), i(e) } function R(t) { let i = C[t.code], e = E[i]; k[i] = !0, D(e, t) } function T(t) { let i = C[t.code], e = P[i]; k[i] = !1, D(e, t) } function L() { k = {} } function F() { let t; for (t = 0; t < 26; t++)C["Key" + String.fromCharCode(t + 65)] = String.fromCharCode(t + 97); for (t = 0; t < 10; t++)C["Digit" + t] = C["Numpad" + t] = "" + t; window.addEventListener("keydown", R), window.addEventListener("keyup", T), window.addEventListener("blur", L) } function W(t, i, { handler: e = "keydown", preventDefault: s = !0 } = {}) { let h = "keydown" == e ? E : P; i._pd = s, [].concat(t).map((t => h[t] = i)) } function H(t, { handler: i = "keydown" } = {}) { let e = "keydown" == i ? E : P;[].concat(t).map((t => delete e[t])) } function I(t) { return !!k[t] } function O(t) { let i = []; return t._dn ? i.push(t._dn) : t.children && t.children.map((t => { i = i.concat(O(t)) })), i } class Y { constructor({ id: t, name: e = t, objects: s = [], context: h = l(), cullObjects: r = !0, cullFunction: n = y, sortFunction: a, ...o }) { this._o = []; let d = h.canvas, c = this._dn = document.createElement("section"); c.tabIndex = -1, c.style = "position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0,0,0,0);", c.id = t, c.setAttribute("aria-label", e), i(c, d), Object.assign(this, { id: t, name: e, context: h, cullObjects: r, cullFunction: n, sortFunction: a, ...o }); let { width: p, height: u } = d, w = p / 2, x = u / 2; this.camera = g({ x: w, y: x, width: p, height: u, context: h, centerX: w, centerY: x, anchor: { x: .5, y: .5 }, render: this._rf.bind(this) }), this.add(s) } set objects(t) { this.remove(this._o), this.add(t) } get objects() { return this._o } add(...t) { t.flat().map((t => { this._o.push(t), O(t).map((t => { this._dn.appendChild(t) })) })) } remove(...t) { t.flat().map((t => { e(this._o, t), O(t).map((t => { i(t, this.context) })) })) } show() { this.hidden = this._dn.hidden = !1; let t = this._o.find((t => t.focus)); t ? t.focus() : this._dn.focus(), this.onShow() } hide() { this.hidden = this._dn.hidden = !0, this.onHide() } destroy() { this._dn.remove(), this._o.map((t => t.destroy && t.destroy())) } lookAt(t) { let { x: i, y: e } = t.world || t; this.camera.x = i, this.camera.y = e } update(t) { this.hidden || this._o.map((i => i.update && i.update(t))) } _rf() { let { _o: t, context: i, _sx: e, _sy: s, camera: h, sortFunction: r, cullObjects: n, cullFunction: a } = this; i.translate(e, s); let o = t; n && (o = o.filter((t => a(h, t)))), r && o.sort(r), o.map((t => t.render && t.render())) } render() { if (!this.hidden) { let { context: t, camera: i } = this, { x: e, y: s, centerX: h, centerY: r } = i; t.save(), this._sx = h - e, this._sy = r - s, t.translate(this._sx, this._sy), i.render(), t.restore() } } onShow() { } onHide() { } } function j() { return new Y(...arguments) } const { canvas: N, context: X } = d(), $ = []; let q = !1; function K(t, i, e, ...s) { if (q) return; q = !0; const h = .48 * N.width, r = S({ x: (N.width - h) / 2, y: (N.height - e) / 2 - 40, width: h, height: e, color: "#899878" }); r.addChild(S({ x: 6, y: 6, width: h - 12, height: e - 12, color: "#222725" })); const n = "px Arial"; r.addChild(v({ y: 20, text: t, textAlign: "center", font: `40${n}`, color: "white", width: h, lineHeight: 1.5 })); r.addChild(v({ x: 16, y: 78, text: i, textAlign: "center", font: `24${n}`, color: "white", width: h - 32, lineHeight: 1.5 })), r.addChild(v({ y: e - 42, text: s.map((t => t.label)).join(" | "), textAlign: "center", font: `20${n}`, color: "white", width: h, lineHeight: 1.5 })); for (const t of s) { const i = () => { a("D_CLOSE"), $.pop(), q = !1, t.action() }; W(t.key, (() => { H(t.key), i() })) } $.push(r), a("D_OPEN") } class G { constructor(t, i) { this.config = t, this.player = i; this.bg = S({ x: 0, y: t.dimensions.height - 80, color: "#222725", width: t.dimensions.width, height: 80 }), this.healthLine = S({ x: 0, y: -7, width: t.dimensions.width * (this.player.health / 100), height: 7, color: "#899878" }), this.bg.addChild(this.healthLine); const e = { text: "", font: "20px Arial", color: "white", textAlign: "left", lineHeight: 1.5 }; this.columns = []; for (let t = 0; t < 13; ++t) { const i = v({ ...e, x: 16 + 80 * t, y: 16 }); this.bg.addChild(i), this.columns.push(i) } } update() { this.healthLine.width = this.config.dimensions.width * (this.player.health / 100), this.columns[0].text = `🌴 ${this.player.wood}`, this.columns[1].text = `🦀 ${this.player.crab}`, this.columns[12].text = `❤️ ${Math.round(this.player.health)}`, this.bg.update() } render() { this.bg.render() } } class U { constructor(t, i) { this.age = 0, this.maxAge = 200 + 200 * Math.random(), this.behavior = 0, this.behaviorCooldown = 0, this.speed = 2, this.maxDistance = 75, this.angle = 2 * Math.PI * Math.random(), this.sprite = S({ x: t, y: i, width: 8, height: 8, color: "red", isAlive: !1, opacity: 0 }) } spawn(t, i) { this.sprite.x = t, this.sprite.y = i } update(t, i, e) { const s = Math.sqrt(Math.pow(t.sprite.x - this.sprite.x, 2), Math.pow(t.sprite.y - this.sprite.y, 2)); if (this.sprite.isAlive && ++this.age > this.maxAge && this.sprite.dx < .01 && this.sprite.dy < .01 || s > 1500 ? (this.sprite.opacity = 0, this.sprite.isAlive = !1) : Math.random() < 5e-4 && !this.sprite.isAlive && (this.maxAge = 600 + 600 * Math.random(), this.sprite.isAlive = !0, this.sprite.x = t.sprite.x + 2e3 * Math.random() - 1e3, this.sprite.y = t.sprite.y + 2e3 * Math.random() - 1e3, this.sprite.opacity = 1), this.sprite.isAlive) { if (--this.behaviorCooldown, this.behaviorCooldown < 0 && (this.behavior = 0), s < this.maxDistance && (i = 0, this.behavior = 1, this.behaviorCooldown = 200, this.angle = c(t.sprite, this.sprite) + Math.random() * Math.PI / 4 - Math.PI / 8), i % (20 + Math.round(20 * Math.random())) == 0) { if (1 === this.behavior) this.angle += Math.random() * Math.PI / 4 - Math.PI / 8, this.speed = 2.1; else if (0 === this.behavior) { const t = Math.random(); this.speed = t < .7 ? 0 : Math.random() - .5, this.angle += Math.random() * Math.PI / 4 - Math.PI / 8 } this.sprite.dx = this.speed * Math.sin(this.angle), this.sprite.dy = this.speed * Math.cos(this.angle) } y(this.sprite, t.sprite) && (this.sprite.isAlive = !1, ++t.crab, ++t.health, this.sprite.opacity = 0), e.tile(this.sprite.x, this.sprite.y) === Q && (this.sprite.dx = -.5 * this.sprite.dx, this.sprite.dy = -.5 * this.sprite.dy), this.sprite.update() } } render() { this.sprite.render() } } class B { constructor(t, i, e) { this.x = t, this.y = i, this.z = e } dot2(t, i) { return this.x * t + this.y * i } dot3(t, i, e) { return this.x * t + this.y * i + this.z * e } } class J { grad3 = [new B(1, 1, 0), new B(-1, 1, 0), new B(1, -1, 0), new B(-1, -1, 0), new B(1, 0, 1), new B(-1, 0, 1), new B(1, 0, -1), new B(-1, 0, -1), new B(0, 1, 1), new B(0, -1, 1), new B(0, 1, -1), new B(0, -1, -1)]; p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]; perm = new Array(512); gradP = new Array(512); F2 = .5 * (Math.sqrt(3) - 1); G2 = (3 - Math.sqrt(3)) / 6; constructor(t) { t > 0 && t < 1 && (t *= 65536), (t = Math.floor(t)) < 256 && (t |= t << 8); for (var i = 0; i < 256; i++) { var e; e = 1 & i ? this.p[i] ^ 255 & t : this.p[i] ^ t >> 8 & 255, this.perm[i] = this.perm[i + 256] = e, this.gradP[i] = this.gradP[i + 256] = this.grad3[e % 12] } } simplex2(t, i) { var e, s, h = (t + i) * this.F2, r = Math.floor(t + h), n = Math.floor(i + h), a = (r + n) * this.G2, o = t - r + a, l = i - n + a; o > l ? (e = 1, s = 0) : (e = 0, s = 1); var d = o - e + this.G2, c = l - s + this.G2, p = o - 1 + 2 * this.G2, u = l - 1 + 2 * this.G2; r &= 255, n &= 255; var y = this.gradP[r + this.perm[n]], w = this.gradP[r + e + this.perm[n + s]], x = this.gradP[r + 1 + this.perm[n + 1]], _ = .5 - o * o - l * l, m = .5 - d * d - c * c, g = .5 - p * p - u * u; return 70 * ((_ < 0 ? 0 : (_ *= _) * _ * y.dot2(o, l)) + (m < 0 ? 0 : (m *= m) * m * w.dot2(d, c)) + (g < 0 ? 0 : (g *= g) * g * x.dot2(p, u))) } fade(t) { return t * t * t * (t * (6 * t - 15) + 10) } lerp(t, i, e) { return (1 - e) * t + e * i } } const Q = "BLOCK"; let V = 0, Z = 0; class tt { constructor(t) { this.tileSize = t, this.blocks = {}, this.mapPerlin = new J(Math.random()) } key(t, i) { return `${t}.${i}` } tile(t, i, e = !1) { if (null != this.blocks[this.key(Math.round(t / this.tileSize), Math.round(i / this.tileSize))]) return this.blocks[this.key(Math.round(t / this.tileSize), Math.round(i / this.tileSize))]; const s = this.mapPerlin.simplex2(t / 2e3, i / 2e3), h = e ? 0 : Math.sin(V) / 15; return s - h < -.2 ? "DEEP_WATER" : s - h < 0 ? "SHALLOW_WATER" : s < .4 ? "SAND" : s < .6 ? "DARK_SAND" : "DARKER_SAND" } trees(t, i, e, s) { const h = [], r = 40, n = Math.round(t) - Math.round(t) % 32, a = Math.round(i) - Math.round(i) % 32; for (let t = n; t < Math.round(e); t += 32)for (let i = a; i < Math.round(s); i += 32) { const e = t + this.simplex2(t, i, 100) * r / 2, s = i + this.simplex2(t, i, -100) * r / 2; if (this.simplex2(e, s, 3e3) < .75) continue; const n = this.tile(e + 160, s, !0), a = this.tile(e - 160, s, !0), o = this.tile(e, s + 160, !0), l = this.tile(e, s - 160, !0); "SHALLOW_WATER" !== n && "DEEP_WATER" !== n && "SHALLOW_WATER" !== a && "DEEP_WATER" !== a && "SHALLOW_WATER" !== o && "DEEP_WATER" !== o && "SHALLOW_WATER" !== l && "DEEP_WATER" !== l && h.push({ x: e, y: s, size: 30 + 32 * Math.abs(this.simplex2(e / 100, s / 100, 900)) }) } return h } findSand() { let t = 0; for (; "DARK_SAND" != this.tile(t++, 0);); return { x: t, y: 0 } } simplex2(t, i, e = 0) { return this.mapPerlin.simplex2(t + e, i + e) } } class it { constructor(t, i, e) { this.width = 39, this.height = 23, this.player = e, this.tileSize = t.tileSize, this.map = i, this.tilesSprites = [], this.tilesSpritesMap = []; for (let t = 0; t < this.width; ++t) { this.tilesSpritesMap[t] = []; for (let i = 0; i < this.height; ++i) { const e = S(); this.tilesSprites.push(e), this.tilesSpritesMap[t][i] = e } } this.trees = {}, this.treesSprites = [], this.particlesSprites = [], this.smokeSprites = [], this.crabs = [], this.crabsSprites = []; for (let t = 0; t < 200; ++t) { this.treesSprites.push(S()), this.particlesSprites.push(S({ isAlive: !1, ttl: 0 })), this.smokeSprites.push(S({ isAlive: !1, color: "grey", ttl: 0 })); const t = new U(200 * Math.random() - 100, 200 * Math.random() - 100); this.crabs.push(t), this.crabsSprites.push(t.sprite) } this.update() } toTile(t) { return "DEEP_WATER" === t ? "#0b92da" : "SHALLOW_WATER" === t ? "#1da7ef" : "SAND" === t ? "#eaca68" : "DARK_SAND" === t ? "#d4b557" : "DARKER_SAND" === t ? "#c2a651" : "#594d29" } update() { Z = ++Z % 216e3, V += .01, this.updateTiles(), this.updateTrees(), Math.abs(this.player.sprite.dx) + Math.abs(this.player.sprite.dy) > .1 && "SHALLOW_WATER" === this.map.tile(this.player.sprite.x, this.player.sprite.y) && this.popParticles(this.particlesSprites, this.player.sprite.x + this.player.sprite.width / 2, this.player.sprite.y + this.player.sprite.height / 2, 1, "#66c3f4", 1), this.updateParticles(), this.updateCrabs(), this.updateActions() } updateCrabs() { for (const t of this.crabs) t.update(this.player, Z, this.map) } updateParticles() { for (const t of this.particlesSprites) t.isAlive && (t.ttl -= 1, t.ttl <= 0 && (t.isAlive = !1), t.dxFunc && (t.dx = t.dxFunc(t)), t.dyFunc && (t.dy = t.dyFunc(t)), t.opacityFunc && (t.opacity = t.opacityFunc(t)), t.update()); for (const t of this.smokeSprites) t.isAlive && (t.ttl -= 1, t.ttl <= 0 && (t.isAlive = !1), t.dxFunc && (t.dx = t.dxFunc(t)), t.dyFunc && (t.dy = t.dyFunc(t)), t.opacityFunc && (t.opacity = t.opacityFunc(t)), t.update()) } updateActions() { if (I("space")) for (const t of this.treesSprites.filter((t => t.isAlive))) y(t, this.player.sprite) && (t.properties.health -= 1.1, Math.round(t.properties.health) % 20 == 0 && this.popParticles(this.particlesSprites, t.x + t.width / 2, t.y + t.height / 2, 3, "#275c27", 2), t.properties.health <= 0 && (this.player.wood += 1 + Math.round(t.width / 30))); if (I("e") && this.player.wood >= 1) { const t = Math.round(this.player.sprite.x / this.tileSize), i = Math.round(this.player.sprite.y / this.tileSize), e = this.map.key(t, i); null == this.map.blocks[e] && (--this.player.wood, this.map.blocks[e] = Q) } } updateTiles() { for (let t = 0; t < this.width; ++t)for (let i = 0; i < this.height; ++i) { const e = Math.round((this.player.sprite.x + this.width * this.tileSize / 2 - t * this.tileSize - Math.round(this.player.sprite.x) % this.tileSize) / this.tileSize) * this.tileSize - 2 * this.tileSize, s = Math.round((this.player.sprite.y + this.height * this.tileSize / 2 - i * this.tileSize - Math.round(this.player.sprite.y) % this.tileSize) / this.tileSize) * this.tileSize - 2 * this.tileSize, h = this.map.tile(e, s), r = this.tilesSpritesMap[t][i]; r.x = e, r.y = s, r.width = this.tileSize + 1, r.height = this.tileSize + 1, r.color = this.toTile(h) } } updateTrees() { const t = this.map.trees(this.player.sprite.x - 600, this.player.sprite.y - 350, this.player.sprite.x + 600, this.player.sprite.y + 350); for (let i = 0; i < this.treesSprites.length; ++i) { const e = this.treesSprites[i]; if (i >= t.length) e.isAlive = !1; else { const s = t[i]; e.x = s.x, e.y = s.y, e.width = s.size, e.height = s.size, e.color = "green"; const h = `${e.x}${e.y}`; this.trees[h] || (this.trees[h] = { health: 100 }), e.properties = this.trees[h], e.isAlive = e.properties.health > 0, e.opacity = e.properties.health > 0 ? 1 : 0 } e.update() } } popParticles(t, i, e, s, h, r, n, a, o = .97, l = .99, d = 300) { for (let c = 0; c < s; ++c) { const s = t.reduce(((t, i) => i.ttl < t.ttl ? i : t), { ttl: 1 / 0 }); s.rotation = 360 * Math.random(); const c = 5 + 5 * Math.random(); s.width = c, s.height = c, null == n && (n = Math.random() * Math.PI * 2), a && (n += 2 * a * Math.random() - a); const p = r * Math.random(); s.dx = Math.sin(n) * p, s.dy = Math.cos(n) * p, s.dxFunc = t => t.dx * o, s.dyFunc = t => t.dy * o, s.opacityFunc = t => t.opacity * l, s.x = i, s.y = e, s.ttl = d, s.isAlive = !0, s.color = h, s.opacity = Math.random() } } } class et { constructor(t, i) { this.wood = 0, this.crab = 0, this.health = 100, this.maxHealth = 100, this.tileSize = t.tileSize, this.maxSpeed = t.maxSpeed, this.map = i, this.sprite = S({ x: 200, y: 200, width: .55 * this.tileSize, height: .55 * this.tileSize, color: "#DA61D0" }) } render() { this.sprite.render() } update() { this.updatePosition(), this.sprite.update(), this.health -= Math.sqrt(Math.pow(this.sprite.dx / 62, 2) + Math.pow(this.sprite.dy / 62, 2)), this.health -= .01 } updatePosition() { this.isMoveRight() && this.canMove(this.sprite.x + this.sprite.dx + this.tileSize / 2, this.sprite.y) ? this.sprite.ddx = 1 : this.isMoveLeft() && this.canMove(this.sprite.x + this.sprite.dx - this.tileSize / 2, this.sprite.y) ? this.sprite.ddx = -1 : (this.sprite.ddx /= 1.2, this.sprite.dx = 0), this.isMoveUp() && this.canMove(this.sprite.x, this.sprite.y + this.sprite.dy - this.tileSize / 2) ? this.sprite.ddy = -1 : this.isMoveDown() && this.canMove(this.sprite.x, this.sprite.y + this.sprite.dy + this.tileSize / 2) ? this.sprite.ddy = 1 : (this.sprite.ddy /= 1.2, this.sprite.dy = 0), this.sprite.dx > 1 && (this.sprite.dx = this.maxSpeed), this.sprite.dx < -1 && (this.sprite.dx = -this.maxSpeed), this.sprite.dy > 1 && (this.sprite.dy = this.maxSpeed), this.sprite.dy < -1 && (this.sprite.dy = -this.maxSpeed) } isMoveLeft() { return I("a") } isMoveRight() { return I("d") } isMoveUp() { return I("w") } isMoveDown() { return I("s") } isAction() { return I("space") } canMove(t, i) { return "DEEP_WATER" !== this.map.tile(t, i) } } class st { constructor(t) { n("D_OPEN", (() => this.paused = !0)), n("D_CLOSE", (() => this.paused = !1)), this.scene = j({ id: "game", objects: [] }), this.map = new tt(t.tileSize), this.player = new et(t, this.map), this.world = new it(t, this.map, this.player), this.hud = new G(t, this.player); const i = this.map.findSand(); this.player.sprite.x = i.x, this.player.sprite.y = i.y, this.plane = S({ x: 300 + this.player.sprite.x + 240 * Math.random() - 120, y: 300 + this.player.sprite.y + 240 * Math.random() - 120, rotation: Math.random() * Math.PI * 2, width: t.tileSize, height: 4 * t.tileSize, color: "white" }), this.plane.addChild(S({ x: t.tileSize / 2 - 35, y: 1.5 * t.tileSize + 10, rotation: Math.PI / 2 + .25, width: .7 * t.tileSize, height: 2.3 * t.tileSize, color: "white" })), this.plane.addChild(S({ x: 2.2 * t.tileSize + t.tileSize / 2, y: 1.5 * t.tileSize, rotation: Math.PI / 2 - .1, width: .7 * t.tileSize, height: 2.6 * t.tileSize, color: "white" })), this.scene.add(...this.world.tilesSprites, ...this.world.particlesSprites, ...this.world.crabsSprites, this.player.sprite, this.plane, ...this.world.treesSprites, ...this.world.smokeSprites); const e = () => K("Welcome to Crab Island", "You're very hungry though. So, better not become too acquainted with those crabs, because you're going to have to eat them.", 240, { label: "(Press enter to continue)", key: "enter", action: () => K("How does this work?", 'Use "wasd" to move. When you move, you lose energy. Use "space" to collect wood. Use "e" to drop a log and form a crab barrier of sorts. Walk on a crab to eat it. Crabs give you energy. Collect the most crabs to win eternal glory.', 340, { label: "(Press enter to continue)", key: "enter", action: () => { } }) }); K("Welcome to the Island", 'So your plane just crashed on this island. At least, you\'ve got an ax. The island has trees. And crabs! Actually, the island is called "Crab Island".', 270, { label: "(Press enter to continue)", key: "enter", action: () => e() }), this.time = 0 } update() { this.time = (this.time + 1) % 1e4, this.paused || (this.scene.lookAt(this.player.sprite), this.scene.camera.setScale(1, 1), this.player.update(), this.world.update(), this.hud.update(), this.time % 10 == 0 && this.world.popParticles(this.world.smokeSprites, this.plane.x, this.plane.y, 1, "grey", .5, this.plane.rotation, Math.random() * Math.PI / 3, 1, .999, 1e4), this.player.health < 0 && K("DEATH", "Rip. You are dead. You starved to death.", 190, { label: "(Press enter to start again)", key: "enter", action: () => a("RST") })) } render() { this.scene.render(), this.hud.render() } } F(); const ht = { dimensions: { width: 4 / 3 * 800, height: 600 }, tileSize: 32, maxSpeed: .5 }; N.width = ht.dimensions.width, N.height = ht.dimensions.height; let rt = new st(ht); n("RST", (() => { rt = new st(ht); const t = $.length; for (let i = 0; i < t; ++i)$.pop() })), z({ update: function () { I("esc") && a("RST"), rt.update(); for (const t of $) t.update() }, render: function () { rt.render(); for (const t of $) t.render() } }).start();</script>
</head>

<body> <canvas width="1000px" height="562px"></canvas> </body>
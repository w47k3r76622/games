"use strict";const e={},t=25;function s(e,t){return e=Math.ceil(e),t=Math.floor(t),Math.floor(Math.random()*(t-e+1))+e}function i(){let e="";const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",s=t.length;for(var i=0;i<20;i++)e+=t.charAt(Math.floor(Math.random()*s));return e}function n(e){return Object.keys(e)}function a(e){return n(e).length}function h(e){const t=Math.random();let s=0;for(let i=0;i<e.length;i++){const n=e[i];if(t<(s+=n.chance))return n.name}}const o=1800,c=1e3,r=s(10,15),m=-1;class l{constructor(){this.id="",this.gameId="",this.speedX=0,this.speedY=m}update(){this.updatePosition()}updatePosition(){this.x+=this.speedX,this.y+=this.speedY}getAngle(e){const t=this.x+this.width/2,s=this.y+this.height/2;let i=e.x,n=e.y;e.width&&e.height&&(i+=e.width/2,n+=e.height/2);const a=-t+i-8,h=-s+n-8;return Math.atan2(h,a)/Math.PI*180}static overlaps(e,t){return e.x<t.x+t.width&&e.x+e.width>t.x&&e.y<t.y+t.height&&e.y+e.height>t.y}static getAllInitPack(t,s){const i=[],n=e[t];for(let e in n[s]){const t=n[s][e];i.push(t.getInitPack())}}static checkCollisionsWithObstacles(t,s,i){const n={x:s,y:i,width:t.width,height:t.height},a=e[t.gameId];for(let e in a.obstacles){const t=a.obstacles[e],s={x:t.x,y:t.y+t.speedY,width:t.width,height:t.height};if(l.overlaps(n,s))return t}return!1}static getEntitySpawnPoint(e){let t,i,n=!0;for(;n;){if("player"==e.type){const s=e.viewportDimensions.width,n=e.viewportDimensions.height;t=Math.random()*(s/2)+s/4,i=Math.random()*(n/3)+n/2}else"enemy"==e.type&&(t=s(0,o),i=-e.height-5);n=l.checkCollisionsWithObstacles(e,t,i)}return{x:t,y:i}}static getAllInitPack(t,s){const i=[],n=e[t];for(let e in n[s]){const t=n[s][e];i.push(t.getInitPack())}return i}}class d extends l{constructor(t){super();const{parent:s,angle:n,weaponName:a}=t;this.parent=s,this.angle=n,this.weaponName=a,this.id=i(),this.gameId=s.gameId,this.width=10,this.height=10,this.x=s.x+s.width/2-this.width/2,this.y=s.y+s.height/2-this.height/2;const h=s.weapon.speed*s.bulletSpeedModifier;this.speedX=Math.cos(this.angle/180*Math.PI)*h,this.speedY=Math.sin(this.angle/180*Math.PI)*h,this.timer=0,this.damage=s.weapon.damage,this.toRemove=!1,this.color=this.parent.color,this.ttl=100,e[this.gameId].bullets[this.id]=this,e[this.gameId].initPack.bullets.push(this.getInitPack())}update(){this.timer++>this.ttl&&(this.toRemove=!0),super.update();const t=e[this.gameId];if("enemy"!=this.parent.type)for(let e in t.enemies){let s=t.enemies[e];if(l.overlaps(this,s)){if(s.hp-=this.damage,s.hp<=0){const e=t.players[this.parent.id];e&&(e.score+=100)}this.toRemove=!0}}for(let e in t.obstacles){let s=t.obstacles[e];l.overlaps(this,s)&&(this.toRemove=!0)}if("player"!=this.parent.type)for(let e in t.players){let s=t.players[e];!s.dead&&l.overlaps(this,s)&&(s.hp-=this.damage,this.toRemove=!0)}}setDamage(e){this.damage=e}getInitPack(){return{id:this.id,x:this.x,y:this.y,width:this.width,height:this.height,color:this.color,parentType:this.parent.type,parentId:this.parent.id,weaponName:this.weaponName}}getUpdatePack(){return{id:this.id,x:this.x,y:this.y}}static updateAll(t){const s=[],i=e[t];for(let e in i.bullets){let t=i.bullets[e];t.update(),t.toRemove?(delete i.bullets[e],i.removePack.bullets.push(t.id)):s.push(t.getUpdatePack())}return s}}class p extends l{constructor(s,n){super(),this.type="enemy",this.toRemove=!1,this.id=i(),this.gameId=s,this.targetId=u.getRandomLivingPlayerId(this.gameId),this.width=32,this.height=32,this.chanceToShoot=1/t,this.maxSpeed=2,this.hp=30,this.hpMax=30,this.bulletSpeedModifier=.4,this.color="#FFF";const a=l.getEntitySpawnPoint(this);this.x=a.x,this.y=a.y;const o=e[this.gameId];if(this.weaponType=h(o.chancesForWeapons),n)for(let e in n)this[e]=n[e];this.weapon=new f(this.weaponType,this),o.decrementRemainingEnemies(),o.enemies[this.id]=this,o.initPack.enemies.push(this.getInitPack())}update(){if(this.hp<=0){this.toRemove=!0,e[this.gameId].incrementWaveKills(),this.weapon.dropable&&new y({gameId:this.gameId,x:this.x,y:this.y,name:this.weapon.name})}const t=e[this.gameId];let s=t.players[this.targetId];if(!s||s.dead){const e=u.getRandomLivingPlayerId(this.gameId);(s=t.players[e])&&(this.targetId=e)}if(this.updateSpeed(s),super.update(),Math.random()<=this.chanceToShoot&&s){const e=this.getAngle(s);this.weapon.attemptShoot(e)}}updateSpeed(e){if(e){const t=e.x-this.x,s=e.y-this.y;if(t>this.maxSpeed/2){this.speedX=this.maxSpeed,l.checkCollisionsWithObstacles(this,this.x+this.speedX,this.y)&&(this.speedX=0)}else if(t<-this.maxSpeed/2){this.speedX=-this.maxSpeed,l.checkCollisionsWithObstacles(this,this.x+this.speedX,this.y)&&(this.speedX=0)}else this.speedX=0;if(s<-this.maxSpeed/2){this.speedY=-this.maxSpeed;const e=l.checkCollisionsWithObstacles(this,this.x,this.y+this.speedY);e&&(this.y=e.y+e.height,this.speedY=e.speedY)}else if(s>this.maxSpeed/2){this.speedY=this.maxSpeed;const e=l.checkCollisionsWithObstacles(this,this.x,this.y+this.speedY);e&&(this.y=e.y-this.height-1,this.speedY=e.speedY)}else this.speedY=m}}getInitPack(){return{id:this.id,x:this.x,y:this.y,width:this.width,height:this.height,hp:this.hp,color:this.color}}getUpdatePack(){return{id:this.id,x:this.x,y:this.y,hp:this.hp}}static updateAll(t){const s=e[t];s.remainingEnemies>0&&Math.random()<=s.chanceForEnemiesToGenerate&&new p(t);const i=[];for(let e in s.enemies){let t=s.enemies[e];t.update(),t.toRemove?(delete s.enemies[e],s.removePack.enemies.push(t.id)):i.push(t.getUpdatePack())}return i}}class g extends l{constructor(t){super(),this.id=i(),this.gameId=t.gameId,this.x=t.x||s(0,o),this.y=t.y||c,this.width=t.width||s(25,150),this.height=t.height||s(25,150),this.toRemove=!1,this.color="#8F9EB2",e[this.gameId].obstacles[this.id]=this,e[this.gameId].initPack.obstacles.push(this.getInitPack())}update(){this.y<-this.height-5&&(this.toRemove=!0),super.update()}getInitPack(){return{id:this.id,x:this.x,y:this.y,width:this.width,height:this.height,color:this.color}}getUpdatePack(){return{id:this.id,x:this.x,y:this.y}}static updateAll(t){Math.random()<=g.chanceToGenerate&&new g({gameId:t});const s=[],i=e[t];for(let e in i.obstacles){let t=i.obstacles[e];t.update(),t.toRemove?(delete i.obstacles[e],i.removePack.obstacles.push(t.id)):s.push(t.getUpdatePack())}return s}}g.chanceToGenerate=1/(3*t);class u extends l{constructor(t){super(),this.type="player",this.id=t.id,this.gameId=t.gameId,this.width=32,this.height=32,this.pressingRight=!1,this.pressingLeft=!1,this.pressingUp=!1,this.pressingDown=!1,this.pressingShoot=!1,this.mouseX=0,this.mouseY=0,this.maxSpeed=10,this.hp=100,this.hpMax=100,this.lives=3,this.score=0,this.diedAt=null,this.dead=!1,this.toRemove=!1,this.weapon=new f("pistol",this),this.bulletSpeedModifier=1,this.viewportDimensions=t.viewportDimensions;const s=a(e[t.gameId].players);this.color=u.colors[s];const i=l.getEntitySpawnPoint(this);this.x=i.x,this.y=i.y,console.log(`[Player constructor] New player created: ${t.id}, adding to game: ${t.gameId}`),e[t.gameId].players[t.id]=this}update(){if(!this.dead){if(this.hp<=0)if(this.diedAt||(this.diedAt=(new Date).getTime(),this.lives--,this.resetWeapon()),this.lives<0)this.dead=!0;else{if((new Date).getTime()-this.diedAt>1e3){this.diedAt=null,this.hp=this.hpMax;const e=l.getEntitySpawnPoint(this);this.x=e.x,this.y=e.y}}if(this.weapon.ammo<=0&&this.resetWeapon(),this.updateSpeed(),super.update(),this.pressingShoot){const e=this.getAngle({x:this.mouseX,y:this.mouseY});this.weapon.attemptShoot(e)}}}updateSpeed(){if(this.pressingRight){this.speedX=this.maxSpeed;const e=l.checkCollisionsWithObstacles(this,this.x+this.speedX,this.y);e&&(this.x=e.x-this.width,this.speedX=0)}else if(this.pressingLeft){this.speedX=-this.maxSpeed;const e=l.checkCollisionsWithObstacles(this,this.x+this.speedX,this.y);e&&(this.x=e.x+e.width,this.speedX=0)}else this.speedX=0;if(this.pressingUp){this.speedY=-this.maxSpeed;const e=l.checkCollisionsWithObstacles(this,this.x,this.y+this.speedY);e&&(this.y=e.y+e.height,this.speedY=e.speedY)}else if(this.pressingDown){this.speedY=this.maxSpeed;const e=l.checkCollisionsWithObstacles(this,this.x,this.y+this.speedY);e&&(this.y=e.y-this.height-1,this.speedY=e.speedY)}else this.speedY=m}setPressingKey(e,t){"right"==e?this.pressingRight=t:"left"==e?this.pressingLeft=t:"up"==e?this.pressingUp=t:"down"==e?this.pressingDown=t:"shoot"===e?this.pressingShoot=t:"mouseAngle"===e&&(this.mouseX=t.x,this.mouseY=t.y)}getInitPack(){return{id:this.id,x:this.x,y:this.y,width:this.width,height:this.height,hp:this.hp,hpMax:this.hpMax,score:this.score,color:this.color,lives:this.lives}}getUpdatePack(){return{id:this.id,x:this.x,y:this.y,hp:this.hp,hpMax:this.hpMax,score:this.score,lives:this.lives,weaponName:this.weapon.name,weaponAmmo:this.weapon.ammo,diedAt:this.diedAt}}resetWeapon(){this.weapon=new f("pistol",this)}static getRandomLivingPlayerId(t){const s=e[t],i=[];for(let e in s.players){const t=s.players[e];t.dead||i.push(t.id)}return i[Math.floor(Math.random()*i.length)]}static onConnect(e,t){console.log("[onConnect] Searching for available games...");const s=w.findOrCreateGame(),i={id:e.id,gameId:s.id,viewportDimensions:t};console.log(`[onConnect] Adding player to game ${s.id}`);const n=new u(i);e.on("keyPress",e=>{n.setPressingKey(e.inputId,e.state)}),e.on("viewportResize",e=>{n.viewportDimensions=e}),e.emit("init",{selfId:e.id,players:u.getAllInitPack(s.id,"players"),enemies:p.getAllInitPack(s.id,"enemies"),bullets:d.getAllInitPack(s.id,"bullets"),obstacles:g.getAllInitPack(s.id,"obstacles"),items:y.getAllInitPack(s.id,"items")}),e.to(s.room).emit("newPlayer",n.getInitPack()),console.log(`[onConnect] Subscribing player to room: ${s.room}`),e.join(s.room)}static findPlayerById(t){const s=n(e);for(let i=0;i<s.length;i++){const a=s[i],h=e[a],o=n(h.players);for(let e=0;e<o.length;e++){const s=o[e];if(s==t)return h.players[s]}}}static updateAll(t){const s=[],i=e[t];for(let e in i.players){let t=i.players[e];t.update(),t.toRemove?(delete i.players[e],i.removePack.players.push(t.id)):s.push(t.getUpdatePack())}return s}static onDisconnect(e){console.log(`[onDisconnect] Player ${e.id} disconnected, marking for removal`);const t=u.findPlayerById(e.id);t&&(t.toRemove=!0)}}u.colors=["#FF5733","#4086fd","#56f572","#FFBD33"];class f{constructor(e,t){this.name=e,this.parent=t;const s=f.weapons[e];for(let e in s)this[e]=s[e]}ableToShoot(){const e=(new Date).getTime()-this.timeLastShot>this.coolDown,t=this.ammo>0;return e&&t}attemptShoot(e){this.ableToShoot()&&this.shootFunction(e,this)}decrementAmmo(){"player"===this.parent.type&&(this.ammo-=1)}static basicShoot(e,t){t.ableToShoot()&&(new d({angle:e,parent:t.parent,weaponName:t.name}),t.decrementAmmo(),t.timeLastShot=(new Date).getTime())}static spreadShot(e,t){if(t.ableToShoot()){[-10,-5,0,5,10].forEach(s=>{new d({angle:e+s,parent:t.parent,weaponName:t.name})}),t.decrementAmmo(),t.timeLastShot=(new Date).getTime()}}static burstShot(e,t){if(t.ableToShoot()){[-2,0,2].forEach(s=>{new d({angle:e+s,parent:t.parent,weaponName:t.name})}),t.decrementAmmo(),t.timeLastShot=(new Date).getTime()}}static flameShot(e,t){if(t.ableToShoot()){const i=s(-10,10);new d({angle:e+i,parent:t.parent,weaponName:t.name}),t.decrementAmmo(),t.timeLastShot=(new Date).getTime()}}}f.weapons={pistol:{damage:10,speed:30,timeLastShot:0,coolDown:400,ammo:Number.MAX_SAFE_INTEGER,shootFunction:f.basicShoot,dropable:!1},chaingun:{damage:10,speed:30,timeLastShot:0,coolDown:40,ammo:s(75,125),shootFunction:f.basicShoot,dropable:!0,color:"whitesmoke"},shotgun:{damage:20,speed:30,timeLastShot:0,coolDown:800,ammo:s(15,25),shootFunction:f.spreadShot,dropable:!0,color:"whitesmoke"},rifle:{damage:30,speed:40,timeLastShot:0,coolDown:200,ammo:s(30,50),shootFunction:f.basicShoot,dropable:!0,color:"whitesmoke"},burstshot:{damage:15,speed:30,timeLastShot:0,coolDown:500,ammo:s(10,20),shootFunction:f.burstShot,dropable:!0,color:"whitesmoke"},flamethrower:{damage:10,speed:30,timeLastShot:0,coolDown:20,ammo:s(150,300),shootFunction:f.flameShot,dropable:!0,color:"whitesmoke"}};class y extends l{constructor(t){super(),this.id=i(),this.gameId=t.gameId,this.x=t.x,this.y=t.y,this.name=t.name,this.color=f.weapons[this.name].color,this.width=15,this.height=15,this.toRemove=!1,e[this.gameId].items[this.id]=this,e[this.gameId].initPack.items.push(this.getInitPack())}update(){this.y<-this.height-5&&(this.toRemove=!0),super.update();const t=e[this.gameId];for(let e in t.players){let s=t.players[e];if(l.overlaps(this,s)){this.toRemove=!0;const e=new f(this.name,s);s.weapon.name===this.name?s.weapon.ammo+=e.ammo:s.weapon=e}}}getInitPack(){return{id:this.id,x:this.x,y:this.y,width:this.width,height:this.height,color:this.color,name:this.name}}getUpdatePack(){return{id:this.id,x:this.x,y:this.y}}static updateAll(t){const s=[],i=e[t];for(let e in i.items){let t=i.items[e];t.update(),t.toRemove?(delete i.items[e],i.removePack.items.push(t.id)):s.push(t.getUpdatePack())}return s}}class w{constructor(){this.id=i(),this.room=`room-${this.id}`,this.initPack={players:[],enemies:[],bullets:[],obstacles:[],items:[]},this.removePack={players:[],enemies:[],bullets:[],obstacles:[],items:[]},this.updatePack={},this.players={},this.bullets={},this.obstacles={},this.enemies={},this.items={},this.totalEnemies=0,this.waveNum=0,this.waveKills=0,this.nextWave(),console.log(`[Game constructor] New game created: ${this.id}`),e[this.id]=this,this.createInitialObstacles()}getFrameUpdateData(){const e={initPack:{},removePack:{},updatePack:{}};for(let t in w.entities){const s=w.entities[t];e.initPack[t]=this.initPack[t],e.removePack[t]=this.removePack[t],e.updatePack[t]=s.updateAll(this.id),this.initPack[t]=[],this.removePack[t]=[]}return e}getState(){return{totalEnemies:this.totalEnemies,waveKills:this.waveKills,waveNum:this.waveNum}}createInitialObstacles(){for(let e=0;e<r;e++)new g({gameId:this.id,y:s(0,c)})}decrementRemainingEnemies(){this.remainingEnemies--}incrementWaveKills(){this.waveKills++,this.waveKills>=this.totalEnemies&&this.nextWave()}nextWave(){for(const e in this.players){const t=this.players[e];t.dead&&(t.lives=0,t.dead=!1)}if(this.waveKills=0,this.waveNum++,this.waveNum%10==0)for(const e in this.players){this.players[e].lives++}const e=w.waves[this.waveNum];if(e){if(this.totalEnemies=e.numEnemies,this.remainingEnemies=this.totalEnemies,this.chanceForEnemiesToGenerate=e.chanceForEnemiesToGenerate,this.chancesForWeapons=e.chancesForWeapons,e.boss){const t=new p(this.id,e.boss.config);console.log(t)}}else this.totalEnemies=Math.max(Math.floor(1.25*this.totalEnemies),50),this.remainingEnemies=this.totalEnemies,this.chanceForEnemiesToGenerate*=1.1,this.chancesForWeapons=w.generateWeightedRandomItems(w.allWeapons)}static findOrCreateGame(){console.log("[findOrCreateGame] Current games:",a(e)),console.log("[findOrCreateGame] Searching for available games...");const t=n(e);for(let s=0;s<t.length;s++){const i=t[s],n=e[i],h=a(n.players);if(console.log("[findOrCreateGame] Existing game",i,"found with",h,"players"),h<4)return console.log("[findOrCreateGame] Available game found:",n.id),n}return console.log("[findOrCreateGame] No available game found, creating new game"),new w}static deleteIfEmpty(t){const s=e[t];if(s){0==a(s.players)&&delete e[t]}}static generateWeightedRandomItems(e){let t=0;const s=[],i=Math.min(Math.random(),.5);s.push({name:"pistol",chance:i}),e.splice(e.indexOf("pistol"),1),t+=i;for(let i=0;i<e.length;i++){const i=e[Math.floor(Math.random()*e.length)],n=Math.random(),a=1-t;if(!(n<=a)){s.push({name:i,chance:a}),t+=a;break}s.push({name:i,chance:n}),t+=n}return t<1&&s.push({name:"pistol",chance:1-t}),s}}w.entities={players:u,enemies:p,bullets:d,obstacles:g,items:y},w.defaultChanceForEnemiesToGenerate=1/(2.6*t),w.waves={1:{numEnemies:5,chancesForWeapons:[{name:"pistol",chance:1}],chanceForEnemiesToGenerate:w.defaultChanceForEnemiesToGenerate},2:{numEnemies:10,chancesForWeapons:[{name:"pistol",chance:1}],chanceForEnemiesToGenerate:1.05*w.defaultChanceForEnemiesToGenerate},3:{numEnemies:15,chancesForWeapons:[{name:"rifle",chance:.1},{name:"pistol",chance:.9}],chanceForEnemiesToGenerate:1.1*w.defaultChanceForEnemiesToGenerate},4:{numEnemies:20,chancesForWeapons:[{name:"rifle",chance:.1},{name:"pistol",chance:.9}],chanceForEnemiesToGenerate:1.2*w.defaultChanceForEnemiesToGenerate},5:{numEnemies:15,chancesForWeapons:[{name:"rifle",chance:.1},{name:"pistol",chance:.9}],chanceForEnemiesToGenerate:1.3*w.defaultChanceForEnemiesToGenerate,boss:{config:{weaponType:"burstshot",width:75,height:75,maxSpeed:2,hp:350,hpMax:350,bulletSpeedModifier:.5,chanceToShoot:10/t}}},6:{numEnemies:25,chancesForWeapons:[{name:"burstshot",chance:.1},{name:"rifle",chance:.05},{name:"pistol",chance:.85}],chanceForEnemiesToGenerate:1.4*w.defaultChanceForEnemiesToGenerate},7:{numEnemies:30,chancesForWeapons:[{name:"rifle",chance:.1},{name:"burstshot",chance:.15},{name:"pistol",chance:.75}],chanceForEnemiesToGenerate:1.5*w.defaultChanceForEnemiesToGenerate},8:{numEnemies:30,chancesForWeapons:[{name:"shotgun",chance:.1},{name:"rifle",chance:.05},{name:"burstshot",chance:.05},{name:"pistol",chance:.8}],chanceForEnemiesToGenerate:1.6*w.defaultChanceForEnemiesToGenerate},9:{numEnemies:20,chancesForWeapons:[{name:"shotgun",chance:.4},{name:"burstshot",chance:.4},{name:"pistol",chance:.2}],chanceForEnemiesToGenerate:1.7*w.defaultChanceForEnemiesToGenerate},10:{numEnemies:10,chancesForWeapons:[{name:"shotgun",chance:1}],chanceForEnemiesToGenerate:1.8*w.defaultChanceForEnemiesToGenerate,boss:{config:{weaponType:"chaingun",width:100,height:100,maxSpeed:2,hp:500,hpMax:500,bulletSpeedModifier:.5,chanceToShoot:10/t}}},11:{numEnemies:35,chancesForWeapons:[{name:"chaingun",chance:.1},{name:"shotgun",chance:.05},{name:"burstshot",chance:.05},{name:"rifle",chance:.05},{name:"pistol",chance:.75}],chanceForEnemiesToGenerate:1.4*w.defaultChanceForEnemiesToGenerate},12:{numEnemies:40,chancesForWeapons:[{name:"chaingun",chance:.08},{name:"shotgun",chance:.08},{name:"burstshot",chance:.08},{name:"rifle",chance:.08},{name:"pistol",chance:.68}],chanceForEnemiesToGenerate:1.4*w.defaultChanceForEnemiesToGenerate},13:{numEnemies:45,chancesForWeapons:[{name:"chaingun",chance:.1},{name:"shotgun",chance:.1},{name:"burstshot",chance:.1},{name:"rifle",chance:.1},{name:"pistol",chance:.6}],chanceForEnemiesToGenerate:1.4*w.defaultChanceForEnemiesToGenerate},14:{numEnemies:50,chancesForWeapons:[{name:"chaingun",chance:.12},{name:"shotgun",chance:.12},{name:"burstshot",chance:.12},{name:"rifle",chance:.12},{name:"pistol",chance:.52}],chanceForEnemiesToGenerate:1.4*w.defaultChanceForEnemiesToGenerate},15:{numEnemies:20,chancesForWeapons:[{name:"shotgun",chance:1}],chanceForEnemiesToGenerate:1.8*w.defaultChanceForEnemiesToGenerate,boss:{config:{weaponType:"flamethrower",width:150,height:150,maxSpeed:2,hp:700,hpMax:700,bulletSpeedModifier:.5,chanceToShoot:10/t}}},20:{numEnemies:50,chancesForWeapons:[{name:"shotgun",chance:1}],chanceForEnemiesToGenerate:1.8*w.defaultChanceForEnemiesToGenerate,boss:{config:{weaponType:"flamethrower",width:200,height:200,maxSpeed:2,hp:1e3,hpMax:1e3,bulletSpeedModifier:.5,chanceToShoot:15/t}}}},w.allWeapons=["shotgun","chaingun","rifle","burstshot","flamethrower","pistol"],setInterval(()=>{for(let t in e){const s=e[t];let i;for(let e in s.players){if(!s.players[e].dead){i=!1;break}i=!0}if(i){console.log(`[setInterval] Game ended: ${t}`),io.to(s.room).emit("gameOver"),delete e[t];break}const n=s.getFrameUpdateData();io.to(s.room).emit("init",n.initPack),io.to(s.room).emit("update",n.updatePack),io.to(s.room).emit("remove",n.removePack);const a=s.getState();io.to(s.room).emit("state",a),w.deleteIfEmpty(t)}},1e3/t),module.exports={io:e=>{console.log(`A user connected (${e.id})`),e.on("startGame",t=>{u.onConnect(e,t)}),e.on("disconnect",()=>{console.log(`User disconnected (${e.id})`),u.onDisconnect(e)})}};
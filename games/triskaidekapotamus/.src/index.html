<!doctype html>
<html lang=en>

<meta charset=utf-8>
<meta name=viewport content="width=device-width, initial-scale=1.0">
<title>Triskaidekapotamus</title>
<style>
  html, body, #m { width: 100%; height: 100%; }
  body { margin: 0; overscroll-behavior: none; }
  #m { display: flex; align-items: center; justify-content: center; }
  #p { position: absolute; top: 1rem; left: 1rem; margin: 0; max-width: calc(100% - 2rem); overflow: hidden; }
</style>

<main id=m><canvas id=c></canvas><pre id=p></pre></main>
<script type=module>const w=window,{devicePixelRatio:dpr,requestAnimationFrame:raf,structuredClone:dup,Object:{entries,fromEntries,is,keys,values},Array:{isArray},JSON:{parse,stringify}}=w;const{atan2,cos,hypot,min,PI:π,round,sign,sin,sqrt}=Math;const ππ=π*2;const isArr=x=>isArray(x);const lerpArr=(as,bs,t)=>as.reduce((acc,a,i)=>(canLerp(a,bs[i])&&acc.push(lerp(a,bs[i],t)),acc),[]);const isNum=x=>typeof x==="number";const lerpNum=(a,b,t)=>(1-t)*a+t*b;const specialKeys=["s","t","w","h"];const shouldLerp=k=>!specialKeys.some(sk=>k.includes(sk));const isObj=x=>x!=null&&!isArr(x)&&typeof x==="object";const lerpObj=(a,b,t)=>fromEntries(entries(a).reduce((acc,[k,v])=>(canLerp(v,b[k])&&shouldLerp(k)?acc.push([k,lerp(v,b[k],t)]):acc.push([k,v]),acc),[]));const canLerp=(a,b)=>a!=null&&b!=null&&typeof a===typeof b;const lerp=(a,b,t)=>{switch(true){case isArr(a)&&isArr(b):{return lerpArr(a,b,t);}case isNum(a)&&isNum(b):{return lerpNum(a,b,t);}case isObj(a)&&isObj(b):{return lerpObj(a,b,t);}case canLerp(a,b):{return round(1-t)?a:b;}default:{throw new Error(`Cannot \`lerp(${stringify(a)}, ${stringify(b)}, ${t})\``);}}};const hull=(()=>{const a=155,h=200,o=sqrt(h*h-a*a),i=atan2(-o,a),j=atan2(o,a),k=j-j/3,p1=new Path2D;p1.ellipse(0,0,30,40,0,0,ππ);p1.moveTo(155+cos(i+j/3+π)*200,sin(k)*200);p1.arc(155,0,200,i+j/3+π,j+π);p1.arc(-155,0,200,i,k);p1.closePath();return p1;})();const oar=(()=>{const p1=new Path2D;p1.rect(-20,-2,90,4);p1.ellipse(90,0,20,10,0,0,ππ);p1.closePath();return p1;})();const boat=ctx=>({x,y,r,rr,lr})=>{ctx.fillStyle="hsla(50, 10%, 90%, 0.6)";ctx.save();ctx.translate(x,y);ctx.rotate(r);ctx.fill(hull,"evenodd");ctx.save();ctx.translate(45,0);ctx.rotate(rr);ctx.fill(oar);ctx.restore();ctx.save();ctx.translate(-45,0);ctx.rotate(lr);ctx.fill(oar);ctx.restore();ctx.restore();};const relaxDist=dt=>(ps,{a,b,s,t})=>{let nx=ps[a].x-ps[b].x,ny=ps[a].y-ps[b].y;const m=nx*nx+ny*ny,c1=1/dt,scale=(t*t-m)/m*s*c1;nx*=scale;ny*=scale;return{...ps,[a]:{...ps[a],x:ps[a].x+nx,y:ps[a].y+ny},[b]:{...ps[b],x:ps[b].x-nx,y:ps[b].y-ny}};};const on=(t,e,l,o=false)=>t.addEventListener(e,l,o);const kd=new Set;const ku=new Set;on(w,"keydown",({key})=>kd.add(key));on(w,"keyup",({key})=>{kd.delete(key);ku.add(key);});const{get,set}=(()=>{let state={t:0,d:1,ps:{},cs:[],x:0,y:0,r:0,px:0,py:0,pr:0,rr:0,lr:π,prr:0,plr:π,cw:0,ch:0,hcw:0,hch:0,ww:0,wh:0};const get=()=>state;const set=p1=>{const nextState=typeof p1==="function"?p1(state):p1;if(!is(nextState,state)){state={...state,...nextState};}};return{get,set};})();const resize=c1=>{const s=1/dpr;on(w,"resize",()=>{const{innerWidth:ww,innerHeight:wh}=w,cw=ww*dpr,ch=wh*dpr,hcw=cw/2,hch=ch/2;set(({x,y,px,py})=>({x:x||hcw,y:y||hch,px:px||hcw,py:py||hch,cw,ch,hcw,hch,ww,wh}));c1.width=cw;c1.height=ch;c1.style.transform=`scale(${s})`;});w.dispatchEvent(new Event("resize"));};resize(c);const createParticle=({x,y,r,px,py,pr})=>({x,y,r:r??0,px:px??x,py:py??y,pr:pr??r??0});const init=()=>{const{hcw,hch}=get(),a=155,h=200,o=sqrt(h*h-a*a),i=atan2(-o,a),j=atan2(o,a),k=j-j/3,ps={a:createParticle({x:hcw,y:hch+sin(i)*h}),b:createParticle({x:hcw+45,y:hch}),c:createParticle({x:hcw-a+cos(i+j/3)*h,y:hch+sin(k)*h}),d:createParticle({x:hcw+a+cos(i+j/3+π)*h,y:hch+sin(k)*h}),e:createParticle({x:hcw-45,y:hch}),f:createParticle({x:hcw+135,y:hch}),g:createParticle({x:hcw-135,y:hch})},cs=[["a","b"],["a","c"],["a","d"],["a","e"],["b","c"],["b","d"],["b","e"],["c","d"],["c","e"],["d","e"],["b","f"],["e","g"]].map(([a,b])=>({a,b,s:.9,t:hypot(ps[b].x-ps[a].x,ps[b].y-ps[a].y)}));set({ps,cs});};const step=(state,dt)=>{p.innerText=entries(state).map(([k,v])=>`${k}: ${stringify(v)}`).join("\n");const{t,ps,cs}=state;let fvy=0,gvy=0;if(kd.has("ArrowUp")){fvy=-1;gvy=-1;}if(kd.has("ArrowRight")){fvy=-1;}if(kd.has("ArrowDown")){fvy=1;gvy=1;}if(kd.has("ArrowLeft")){gvy=-1;}set({t:t+dt,ps:cs.reduce(relaxDist(dt),fromEntries(entries(ps).map(([k,v])=>{const vvx=v.x-v.px;let vvy=v.y-v.py;if(k==="f"){vvy+=fvy;}if(k==="g"){vvy+=gvy;}return[k,{...v,x:v.x+vvx*.9,y:v.y+vvy*.9,px:v.x,py:v.y}];})))});};const ctx=c.getContext("2d"),b=boat(ctx);const draw=state=>{const{ps,cs,cw,ch}=state;ctx.fillStyle="hsl(100, 40%, 60%)";ctx.fillRect(0,0,cw,ch);b(state);values(ps).forEach(({x,y})=>{ctx.save();ctx.translate(x,y);ctx.beginPath();ctx.arc(0,0,5,0,ππ);ctx.stroke();ctx.restore();});cs.forEach(({a,b})=>{ctx.beginPath();ctx.moveTo(ps[a].x,ps[a].y);ctx.lineTo(ps[b].x,ps[b].y);ctx.stroke();});};const loop=(()=>{const dt=10;let pt=performance.now(),ot=0,ft=0;init();return t=>{raf(loop);ft=t-pt;pt=t;ot+=ft;let state=get();while(ot>=10){state=get();step(state,10);ot-=dt;}draw(lerp(state,get(),ot/10));};})();raf(loop);</script>

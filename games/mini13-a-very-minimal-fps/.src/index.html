<canvas id=c />
<script>
c.width=window.innerWidth,c.height=window.innerHeight;var n,e={},a=0;n=0;var o=!0;for(an in g=c.getContext("webgl2"))g[an[0]+an[6]]=g[an];c.onmousemove=e=>{a+=e.movementX,n+=e.movementY},onkeydown=onkeyup=n=>{e[n.key]="d"==n.type[3]};var r=n=>e[n];window.onfocus=n=>o=!0,window.onblur=n=>o=!1;var t="#version 300 es\nprecision highp float;\n\nout vec3 vVertex;\nout vec3 vNormal;\n\nlayout(std140) uniform CubeData {\n    ivec4 uData[4096];\n};\n\nuniform vec2 uResolution;\nuniform vec3 uCameraPosition;\nuniform float uCameraYaw;\nuniform float uCameraPitch;\nuniform float uGlobalYaw;\nuniform float uGlobalPitch;\nuniform bool uUseCamera;\nuniform bool uSphere;\nuniform float uScale;\n\nuniform vec3 uSpheres[512];\n\nconst float fov = radians(60.0);\nconst float near = 0.1;\nconst float far = 1000.0;\nconst vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\nconst vec3 cubeVertices[8] =\n    vec3[8](vec3(-0.5, -0.5, -0.5), vec3(0.5, -0.5, -0.5), vec3(0.5, 0.5, -0.5), vec3(-0.5, 0.5, -0.5),\n            vec3(-0.5, -0.5, 0.5), vec3(0.5, -0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(-0.5, 0.5, 0.5));\n\nconst int cubeIndices[36] =\n    int[36](0, 1, 2, 2, 3, 0, 1, 5, 6, 6, 2, 1, 5, 4, 7, 7, 6, 5, 4, 0, 3, 3, 7, 4, 3, 2, 6, 6, 7, 3, 4, 5, 1, 1, 0, 4);\n\nconst vec3 cubeNormals[6] = vec3[6](vec3(0.0, 0.0, -1.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0),\n                                    vec3(-1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, -1.0, 0.0));\n\nfloat random(float seed) {\n    return fract(sin(seed) * 43758.5453);\n}\n\nmat4 computeProjectionMatrix() {\n    float aspect = uResolution.x / uResolution.y;\n    float f = 1.0 / tan(fov * 0.5);\n    float rangeInv = 1.0 / (near - far);\n\n    return mat4(f / aspect, 0.0, 0.0, 0.0, 0.0, f, 0.0, 0.0, 0.0, 0.0, (near + far) * rangeInv, -1.0, 0.0, 0.0,\n                near * far * rangeInv * 2.0, 0.0);\n}\n\nmat4 computeViewMatrix() {\n    vec3 cameraPosition = uCameraPosition;\n\n    vec3 cameraDirection;\n    cameraDirection.x = cos(uCameraPitch) * sin(uCameraYaw);\n    cameraDirection.y = sin(uCameraPitch);\n    cameraDirection.z = cos(uCameraPitch) * cos(uCameraYaw);\n\n    vec3 zaxis = normalize(cameraDirection);\n    vec3 xaxis = normalize(cross(cameraUp, zaxis));\n    vec3 yaxis = cross(zaxis, xaxis);\n\n    return mat4(xaxis.x, yaxis.x, zaxis.x, 0.0, xaxis.y, yaxis.y, zaxis.y, 0.0, xaxis.z, yaxis.z, zaxis.z, 0.0,\n                -dot(xaxis, cameraPosition), -dot(yaxis, cameraPosition), -dot(zaxis, cameraPosition), 1.0);\n}\n\nconst vec3 sphereVertices[12] = vec3[](\n    vec3(0.0, 1.0, 0.0), vec3(0.894427, 0.447214, 0.0), vec3(0.276393, 0.447214, 0.850651),\n    vec3(-0.723607, 0.447214, 0.525731), vec3(-0.723607, 0.447214, -0.525731), vec3(0.276393, 0.447214, -0.850651),\n    vec3(0.0, -1.0, 0.0), vec3(-0.894427, -0.447214, 0.0), vec3(-0.276393, -0.447214, -0.850651),\n    vec3(0.723607, -0.447214, -0.525731), vec3(0.723607, -0.447214, 0.525731), vec3(-0.276393, -0.447214, 0.850651));\n\nconst int sphereIndices[60] =\n    int[](0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 1, 1, 10, 2, 2, 11, 3, 3, 7, 4, 4, 8, 5, 5, 9, 1, 6, 7, 8, 6, 8, 9,\n          6, 9, 10, 6, 10, 11, 6, 11, 7, 1, 9, 10, 2, 10, 11, 3, 11, 7, 4, 7, 8, 5, 8, 9);\n\nvoid main() {\n    vec3 position;\n    vec3 normal;\n\n    if (uSphere) {\n        int sphereIndex = int(gl_VertexID / 60);\n        int vertexIndex = sphereIndices[gl_VertexID % 60];\n        position = sphereVertices[vertexIndex];\n        normal = normalize(position);\n        position *= uScale;\n\n        position += uSpheres[sphereIndex];\n\n        vVertex = position;\n    } else {\n        int cubeIndex = int(gl_VertexID / 36);\n        int faceIndex = int((gl_VertexID % 36) / 6);\n        int vertexIndex = cubeIndices[gl_VertexID % 36];\n        position = cubeVertices[vertexIndex];\n\n        vVertex = position;\n\n        int value = int(uData[int(cubeIndex / 4)][cubeIndex % 4]);\n        float x = float(value & 255);\n        float y = float((value >> 8) & 255);\n        float z = float((value >> 16) & 255);\n\n        position = position + vec3(x, y, z);\n\n        position *= uScale;\n\n        normal = cubeNormals[faceIndex];\n    }\n\n    float cosYaw = cos(uGlobalYaw);\n    float sinYaw = sin(uGlobalYaw);\n    float cosPitch = cos(uGlobalPitch);\n    float sinPitch = sin(uGlobalPitch);\n    mat3 rotationMatrix = mat3(cosYaw, 0.0, -sinYaw, sinYaw * sinPitch, cosPitch, cosYaw * sinPitch, sinYaw * cosPitch,\n                               -sinPitch, cosYaw * cosPitch);\n\n    position = rotationMatrix * position;\n\n    mat4 projection = computeProjectionMatrix();\n    mat4 view = computeViewMatrix();\n\n    gl_Position = projection * view * vec4(position, 1.0);\n    vNormal = rotationMatrix * normal;\n\n    if (!uUseCamera) {\n        gl_Position = projection * vec4(position, 1.0);\n    }\n}\n",i=g.cS(g.VERTEX_SHADER);g.sS(i,t),g.compileShader(i),g.getShaderParameter(i,g.COMPILE_STATUS)||(console.log("src/Main.hx:32:","An error occurred compiling the shaders: "),console.log("src/Main.hx:33:",g.getShaderInfoLog(i))),t="#version 300 es\nprecision highp float;\n\nuniform vec2 uResolution;\nuniform float uScale;\nuniform float uCameraYaw;\nuniform float uCameraPitch;\nuniform bool uSphere;\n\nin vec3 vVertex;\nin vec3 vNormal;\nout vec4 fragColor;\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(random(i), random(i + vec2(1.0, 0.0)), u.x),\n               mix(random(i + vec2(0.0, 1.0)), random(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 st) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 0.0;\n    for (int i = 0; i < 5; i++) {\n        value += amplitude * noise(st);\n        st *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nvoid main() {\n    vec3 lightDir = normalize(vec3(1.0, 2.0, 1.0));\n    vec3 ambient = vec3(0.3, 0.3, 0.3);\n    float diff = max(dot(normalize(vNormal), lightDir), 0.0);\n    vec3 litColor;\n\n    if (uScale >= 999.0) {\n        vec2 uv = gl_FragCoord.xy / uResolution;\n        uv.x -= uCameraYaw * 0.5;\n        uv.y -= uCameraPitch;\n\n        float cloudNoise = fbm(uv * 2.0);\n        float cloudShape = smoothstep(0.4, 0.6, cloudNoise);\n        float cloudDensity = smoothstep(0.1, 0.3, cloudNoise) * 0.1 + cloudShape * 0.2;\n        vec3 skyColorTop = vec3(0.4, 0.6, 1.0);\n        vec3 skyColorBottom = vec3(0.7, 0.8, 1.0);\n        vec3 cloudColor = vec3(1.0);\n        vec3 skyColor = mix(skyColorBottom, skyColorTop, uv.y);\n\n        litColor = mix(skyColor, cloudColor, cloudDensity);\n    }\n    else if(uScale < 0.1)\n    {\n        litColor = vec3(0.2, 0.1, 0.1);\n\n\n    } else {\n        vec3 baseColor;\n        if (vVertex.y > sin((vVertex.x + vVertex.z) * 30.0) * 0.1) {\n            float squareSize = 0.01;\n            vec3 squarePos = floor(vVertex.xyz / squareSize);\n            float random = fract(sin(dot(squarePos, vec3(12.9898, 78.233, 37.67))) * 43758.5453);\n            vec3 light = vec3(0.1, 0.8, 0.2);\n            vec3 dark = vec3(0.1, 0.6, 0.2);\n            baseColor = mix(light, dark, step(0.5, random));\n        } else {\n            float squareSize = 0.1;\n            vec3 squarePos = floor(vVertex.xyz / squareSize);\n            float random = fract(sin(dot(squarePos, vec3(12.9898, 78.233, 37.67))) * 43758.5453);\n            vec3 light = vec3(0.4, 0.2, 0.0);\n            vec3 dark = vec3(0.6, 0.3, 0.0);\n            baseColor = mix(light, dark, step(0.5, random));\n        }\n\n        if(uSphere)\n        {\n            float squareSize = 0.1;\n            vec3 squarePos = floor(vVertex.xyz / squareSize);\n            float random = fract(sin(dot(squarePos, vec3(12.9898, 78.233, 37.67))) * 43758.5453);\n            vec3 light = vec3(0.4, 0.0, 0.0);\n            vec3 dark = vec3(0.6, 0.0, 0.0);\n            baseColor = mix(light, dark, step(0.5, random));\n        }\n\n        litColor = ambient + baseColor * (diff * 0.6 + 0.4);\n    }\n\n    vec2 uv = gl_FragCoord.xy / uResolution;\n    vec2 center = vec2(0.5, 0.5);\n    float crosshairSize = 0.01;\n    float crosshairThickness = 0.002;\n\n    // Calculate aspect ratio\n    float aspectRatio = uResolution.x / uResolution.y;\n\n    // Adjust UV coordinates for aspect ratio\n    vec2 adjustedUV = (uv - center) * vec2(aspectRatio, 1.0) + center;\n\n    if (abs(adjustedUV.x - center.x) < crosshairThickness && abs(adjustedUV.y - center.y) < crosshairSize ||\n        abs(adjustedUV.y - center.y) < crosshairThickness && abs(adjustedUV.x - center.x) < crosshairSize) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } else {\n        fragColor = vec4(litColor, 1.0);\n    }\n}\n";var s=g.cS(g.FRAGMENT_SHADER);g.sS(s,t),g.compileShader(s),g.getShaderParameter(s,g.COMPILE_STATUS)||(console.log("src/Main.hx:32:","An error occurred compiling the shaders: "),console.log("src/Main.hx:33:",g.getShaderInfoLog(s)));var l=g.cP();g.aS(l,i),g.aS(l,s),g.lo(l),g.getProgramParameter(l,g.LINK_STATUS)||(console.log("src/Main.hx:47:","An error occurred linking the program: "),console.log("src/Main.hx:48:",g.getProgramInfoLog(l))),g.ug(l),g.enable(g.DEPTH_TEST),g.disable(g.CULL_FACE);for(var v=g.getUniformLocation(l,"uTime"),u=(g.getUniformLocation(l,"uData"),new Uint32Array(16384)),f=0,h=0,m=30;h<m;)for(var x=h++,d=0;d<30;){var p=d++;if(u[f]=0|x|p<<16,f+=1,Math.random()>.9)for(var M=1,w=4*Math.random()|0;M<w;){var C=M++;u[f]=x|C<<8|p<<16,f+=1}}var y=g.createBuffer();g.bindBuffer(g.UNIFORM_BUFFER,y),g.bufferData(g.UNIFORM_BUFFER,u,g.STATIC_DRAW),g.bindBuffer(g.UNIFORM_BUFFER,null);var b,P,z=g.getUniformBlockIndex(l,"CubeData");g.uniformBlockBinding(l,z,0),g.bindBufferBase(g.UNIFORM_BUFFER,0,y);var V=0;P=1,b=5;var S,I,D,Y,k=0,q=0,U=g.getUniformLocation(l,"uCameraPosition"),j=g.getUniformLocation(l,"uCameraYaw"),R=g.getUniformLocation(l,"uCameraPitch"),A=g.getUniformLocation(l,"uGlobalYaw"),N=g.getUniformLocation(l,"uGlobalPitch"),_=g.getUniformLocation(l,"uUseCamera"),G=g.getUniformLocation(l,"uSphere"),T=g.getUniformLocation(l,"uScale"),F=g.getUniformLocation(l,"uSpheres"),B=15;I=10,S=15;var K,E=0;Y=0,D=0;var H=0;K=0;var J=!1,L=0,O=g.getUniformLocation(l,"uResolution"),Q=(n,e)=>[n[0]*e,n[1]*e,n[2]*e],W=(n,e,a)=>{if(e<1)return!0;for(var o=Math.floor(n),r=Math.floor(e),t=Math.floor(a),i=-1;i<2;)for(var c=i++,s=-1;s<2;)for(var l=s++,v=-1;v<2;){var h=o+c,g=r+l,m=t+v++;if(g>=0&&g<60)for(var x=0,d=f;x<d;){var p=x++,M=u[p],w=255&M,C=M>>8&255,y=M>>16&255;if(w==h&&C==g&&y==m){var b=Math.max(Math.abs(n-w)-.5,0),P=Math.max(Math.abs(e-C)-.5,0),z=Math.max(Math.abs(a-y)-.5,0);if(b*b+P*P+z*z<.4*.4)return!0}}}return!1},X=0,Z=[],$=[],nn=13,en=new Float32Array(3*nn);for(h=0,m=nn;h<m;){var an=h++;en[3*an]=30*Math.random(),en[3*an+1]=4*Math.random()+2,en[3*an+2]=30*Math.random(),Z.push([3*(2*Math.random()-1),0,3*(2*Math.random()-1)]),$.push(0)}g.uniform3fv(F,en),g.uniform2f(O,c.width,c.height);var on=[],rn=!1;c.onmousedown=n=>{c.requestPointerLock(),rn=!0},c.onmouseup=n=>{rn=!1};var tn=(n,e,a,o)=>{var r=n-en[3*o],t=e-en[3*o+1],i=a-en[3*o+2];return r*r+t*t+i*i<.25},cn=null,sn=n=>{null!=cn&&cn.remove(),(cn=window.document.createElement("div")).innerHTML=n,cn.style.position="absolute",cn.style.top="50%",cn.style.left="50%",cn.style.transform="translate(-50%, -50%)",cn.style.fontSize="24px",cn.style.color="white",cn.style.fontFamily="Arial, sans-serif",cn.style.textAlign="center",cn.style.padding="20px",cn.style.backgroundColor="rgba(0, 0, 0, 0.7)",cn.style.borderRadius="10px",window.document.body.appendChild(cn)};sn("Kill all 13 monsters!");var ln=null;ln=e=>{if(o){(e/=1e3)<10&&e>3&&null!=cn&&null!=cn&&(cn.remove(),cn=null);var t=e-X;X=e,rn&&(n=>{if(!(n-L<.1)){L=n;var e,a,o=0*(Math.random()-.5),r=0*(Math.random()-.5),t=0*(Math.random()-.5),i=(a=Math.sqrt((e=[Math.cos(q)*Math.sin(k)+o,Math.sin(q)+r,Math.cos(q)*Math.cos(k)+t])[0]*e[0]+e[1]*e[1]+e[2]*e[2]),[e[0]/a,e[1]/a,e[2]/a]);on.push({position:[V,P-.1,b],o:Q(i,-20),t:0})}})(e),g.uniform1f(v,e),k-=.002*a,q=Math.max(Math.min(q+=.002*n,Math.PI/2),-Math.PI/2);var i=Math.cos(q)*Math.sin(k),c=Math.cos(q)*Math.cos(k),s=Math.cos(k),l=-Math.sin(k);H=0,K=0;var u=I;r("w")&&(H-=20*i,K-=20*c,console.log("src/Main.hx:338:","yep")),r("s")&&(H+=20*i,K+=20*c),r("a")&&(H-=20*s,K-=20*l),r("d")&&(H+=20*s,K+=20*l),E+=H*t,D+=K*t,0==H&&(E*=Math.pow(1-10*t,2)),0==K&&(D*=Math.pow(1-10*t,2));var f=Math.sqrt(E*E+D*D);f>4&&(E*=4/f,D*=4/f),Y+=-15*t,J&&r(" ")&&(Y=8,J=!1);var h=I+Y*t,m=S+D*t;W(z=B+E*t,I,S)?(E=0,B+=.01*(z>B?-1:1)):B=z,W(B,h,S)?(Y<0&&(J=!0),Y=0,I=u):(I=h,J=!1),W(B,I,m)?(D=0,S+=.01*(m>S?-1:1)):S=m,V=B,P=I+.2,b=S,g.uniform3f(U,V,P,b),g.uniform1f(j,k),g.uniform1f(R,q),g.uniform1i(G,0),g.uniform1i(_,0),g.uniform1f(T,1e3),g.dr(g.TRIANGLES,0,36),g.uniform1f(A,0),g.uniform1f(N,0),g.uniform1i(_,1),g.uniform1f(T,1),g.dr(g.TRIANGLES,0,589824),g.uniform1i(G,1),g.uniform1f(T,.5),g.dr(g.TRIANGLES,0,60*nn);for(var x=new Float32Array(3*on.length),d=0,p=[],M=0,w=on;M<w.length;){var C=w[M];++M,(n=>{if(n.t+=t,n.t>10)return!1;if(n.position[0]+=n.o[0]*t,n.position[1]+=n.o[1]*t,n.position[2]+=n.o[2]*t,W(n.position[0],n.position[1],n.position[2]))return!1;for(var e=0,a=nn;e<a;){var o=e++;if(tn(n.position[0],n.position[1],n.position[2],o)){for(var r=o,i=nn-1;r<i;){var c=r++;en[3*c]=en[3*(c+1)],en[3*c+1]=en[3*(c+1)+1],en[3*c+2]=en[3*(c+1)+2],Z[c]=Z[c+1],$[c]=$[c+1]}return nn-=1,!1}}return x[3*d]=n.position[0],x[3*d+1]=n.position[1],x[3*d+2]=n.position[2],d+=1,!0})(C)&&p.push(C)}for(on=p,x.length>0&&(g.uniform3fv(F,x),g.uniform1f(T,.02),g.dr(g.TRIANGLES,0,60*on.length)),g.uniform1i(G,0),a=n=0,p=0,M=nn;p<M;){var y=p++;e-$[y]>2e3&&(Z[y]=[3*(2*Math.random()-1),0,3*(2*Math.random()-1)],$[y]=e);var z=en[3*y]+Z[y][0]*t;m=en[3*y+2]+Z[y][2]*t,(z<0||z>=30)&&(Z[y][0]*=-1,z=Math.max(0,Math.min(z,29.9))),(m<0||m>=30)&&(Z[y][2]*=-1,m=Math.max(0,Math.min(m,29.9))),en[3*y]=z,en[3*y+2]=m}g.uniform3fv(F,en.subarray(0,3*nn)),0==nn&&sn("Congratulations!<br>You defeated all monsters!"),window.requestAnimationFrame(ln)}else window.setTimeout((()=>{ln(e+1)}),1e3)},window.requestAnimationFrame(ln);
</script>
